<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SLOCCount Web Analyzer</title>
  <meta name="description" content="Analyze source code in the browser for SLOC and rough COCOMO cost estimates.">
  <link rel="icon" href="../favicon.ico" sizes="any">
  <link rel="stylesheet" href="../css/bootstrap-build.css">
  <link rel="stylesheet" href="../css/consolidated-fonts.css">
  <style>
    body { background: var(--bs-body-bg); }
    .app-wrap { max-width: 1120px; }
    .muted-note { color: var(--bs-secondary-color); font-size: 0.9rem; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .table-fixed th, .table-fixed td { vertical-align: middle; }
  </style>
</head>
<body>
  <main class="container app-wrap py-4">
    <div class="mb-3">
      <h1 class="h2 mb-1">SLOCCount Web Analyzer</h1>
      <p class="mb-0 muted-note">Client-side Source Lines of Code analysis with rough Basic COCOMO cost and effort estimates.</p>
      <p id="loadedCounters" class="mb-0 mt-1 muted-note">Loaded counters: initializing…</p>
    </div>

    <div id="status" class="alert alert-secondary" role="status" aria-live="polite">Ready.</div>

    <ul class="nav nav-pills mb-3" id="inputTabs" role="tablist">
      <li class="nav-item" role="presentation"><button class="nav-link active" id="paste-tab" data-bs-toggle="pill" data-bs-target="#paste-pane" type="button" role="tab">Paste Code</button></li>
      <li class="nav-item" role="presentation"><button class="nav-link" id="github-tab" data-bs-toggle="pill" data-bs-target="#github-pane" type="button" role="tab">GitHub Repository</button></li>
      <li class="nav-item" role="presentation"><button class="nav-link" id="zip-tab" data-bs-toggle="pill" data-bs-target="#zip-pane" type="button" role="tab">Upload ZIP</button></li>
    </ul>

    <div class="tab-content">
      <section class="tab-pane fade show active" id="paste-pane" role="tabpanel" aria-labelledby="paste-tab">
        <div class="card mb-3">
          <div class="card-body">
            <div class="row g-3">
              <div class="col-md-4">
                <label for="pasteFilename" class="form-label">Filename</label>
                <input id="pasteFilename" class="form-control" placeholder="example.py">
              </div>
              <div class="col-12">
                <label for="pasteCode" class="form-label">Code</label>
                <textarea id="pasteCode" class="form-control mono" rows="14" placeholder="Paste source code here..."></textarea>
              </div>
            </div>
            <button id="analyzePasteBtn" class="btn btn-primary mt-3">Analyze</button>
          </div>
        </div>
      </section>

      <section class="tab-pane fade" id="github-pane" role="tabpanel" aria-labelledby="github-tab">
        <div class="card mb-3">
          <div class="card-body">
            <div class="row g-3">
              <div class="col-lg-8">
                <label for="githubRepo" class="form-label">Repository</label>
                <input id="githubRepo" class="form-control" placeholder="owner/repo or https://github.com/owner/repo">
              </div>
              <div class="col-lg-4">
                <label for="githubRef" class="form-label">Branch / Ref (optional)</label>
                <input id="githubRef" class="form-control" placeholder="main">
              </div>
            </div>
            <p class="muted-note mt-2 mb-0">Public repositories only. For very large repos, ZIP mode is more reliable.</p>
            <button id="analyzeGithubBtn" class="btn btn-primary mt-3">Analyze Repository</button>
          </div>
        </div>
      </section>

      <section class="tab-pane fade" id="zip-pane" role="tabpanel" aria-labelledby="zip-tab">
        <div class="card mb-3">
          <div class="card-body">
            <label for="zipFile" class="form-label">ZIP Archive</label>
            <input id="zipFile" class="form-control" type="file" accept=".zip,application/zip">
            <p class="muted-note mt-2 mb-0">All analysis happens in your browser. ZIP processing uses JSZip loaded on demand.</p>
            <button id="analyzeZipBtn" class="btn btn-primary mt-3">Analyze ZIP</button>
          </div>
        </div>
      </section>
    </div>

    <section id="results" class="d-none">
      <div class="row g-3 mb-3">
        <div class="col-6 col-md-2"><div class="card"><div class="card-body"><div class="text-secondary small">Total Lines</div><div id="totalLines" class="h4 mb-0">0</div></div></div></div>
        <div class="col-6 col-md-2"><div class="card"><div class="card-body"><div class="text-secondary small">Languages</div><div id="totalLanguages" class="h4 mb-0">0</div></div></div></div>
        <div class="col-6 col-md-2"><div class="card"><div class="card-body"><div class="text-secondary small">Files</div><div id="totalFiles" class="h4 mb-0">0</div></div></div></div>
        <div class="col-6 col-md-3"><div class="card"><div class="card-body"><div class="text-secondary small">Est. Person-Years</div><div id="personYears" class="h4 mb-0">0</div></div></div></div>
        <div class="col-12 col-md-3"><div class="card"><div class="card-body"><div class="text-secondary small">Est. Cost (USD)</div><div id="estCost" class="h4 mb-0">$0</div></div></div></div>
      </div>

      <div class="card mb-3">
        <div class="card-header d-flex justify-content-between align-items-center">
          <strong>Language Breakdown</strong>
          <span id="analyzedSource" class="badge text-bg-secondary">—</span>
        </div>
        <div class="table-responsive">
          <table class="table table-striped table-hover table-fixed mb-0">
            <thead>
              <tr><th>Language</th><th class="text-end">Lines</th><th class="text-end">%</th><th class="text-end">Files</th></tr>
            </thead>
            <tbody id="languageTableBody"></tbody>
          </table>
        </div>
      </div>

      <div class="card mb-3">
        <div class="card-header d-flex justify-content-between align-items-center">
          <strong>Unmapped File Types</strong>
          <span id="unmappedTypeCount" class="badge text-bg-secondary">0</span>
        </div>
        <div class="table-responsive">
          <table class="table table-striped table-hover table-fixed mb-0">
            <thead>
              <tr><th>Type</th><th class="text-end">Files</th><th>Example</th></tr>
            </thead>
            <tbody id="unmappedTypeBody">
              <tr><td colspan="3" class="text-body-secondary">Run analysis to list file types not included by current mappings.</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="card mb-3">
        <div class="card-header"><strong>Cost Model (Basic COCOMO)</strong></div>
        <div class="card-body">
          <div class="row g-3">
            <div class="col-sm-12 col-lg-6">
              <label class="form-label" for="cocomoModeInput">Calculation Mode</label>
              <select id="cocomoModeInput" class="form-select">
                <option value="by-file-year" selected>By file created year (default)</option>
                <option value="original">Original formula (manual constants)</option>
                <option value="force-year">Force single year for all files</option>
              </select>
            </div>
            <div class="col-sm-6 col-lg-3">
              <label class="form-label" for="forceYearInput">Forced Year</label>
              <select id="forceYearInput" class="form-select"></select>
            </div>
            <div class="col-sm-6 col-lg-3"><label class="form-label" for="salaryInput">Annual Salary (USD)</label><input id="salaryInput" class="form-control" type="number" value="56286"></div>
            <div class="col-sm-6 col-lg-3"><label class="form-label" for="overheadInput">Overhead Multiplier</label><input id="overheadInput" class="form-control" type="number" step="0.1" value="2.4"></div>
            <div class="col-sm-6 col-lg-2"><label class="form-label" for="aInput">Effort A</label><input id="aInput" class="form-control" type="number" step="0.01" value="2.4"></div>
            <div class="col-sm-6 col-lg-2"><label class="form-label" for="bInput">Effort B</label><input id="bInput" class="form-control" type="number" step="0.01" value="1.05"></div>
            <div class="col-sm-6 col-lg-1"><label class="form-label" for="cInput">Sched C</label><input id="cInput" class="form-control" type="number" step="0.01" value="2.5"></div>
            <div class="col-sm-6 col-lg-1"><label class="form-label" for="dInput">Sched D</label><input id="dInput" class="form-control" type="number" step="0.01" value="0.38"></div>
          </div>
          <p id="cocomoModeNote" class="muted-note mt-2 mb-0">Mode: By file created year.</p>
          <button id="recalcBtn" class="btn btn-outline-secondary btn-sm mt-3">Recalculate</button>

          <div class="table-responsive mt-3">
            <table class="table table-sm table-striped mb-0">
              <thead>
                <tr><th>Year</th><th class="text-end">Files</th><th class="text-end">Lines</th><th class="text-end">Cost (USD)</th></tr>
              </thead>
              <tbody id="yearCostBody">
                <tr><td colspan="4" class="text-body-secondary">Run an analysis to see per-year costing.</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <div class="alert alert-warning mb-0">
        <strong>About estimates:</strong> These are rough Basic COCOMO estimates (Barry Boehm), intended for directional planning only. They are not commitments or forecasts.
      </div>
    </section>
  </main>

  <script>
    const SLOC_ASSET_BASE = './lib';
    const DOC_BUCKET_LANG = 'Documents';
    const DATA_CONFIG_BUCKET_LANG = 'Data/Config';
    const COUNTER_MAP = {
      py: { counter: 'python_count', type: 'perl', lang: 'Python' },
      rb: { counter: 'ruby_count', type: 'perl', lang: 'Ruby' },
      pl: { counter: 'perl_count', type: 'perl', lang: 'Perl' },
      pm: { counter: 'perl_count', type: 'perl', lang: 'Perl' },
      ada: { counter: 'ada_count', type: 'perl', lang: 'Ada' },
      adb: { counter: 'ada_count', type: 'perl', lang: 'Ada' },
      ads: { counter: 'ada_count', type: 'perl', lang: 'Ada' },
      asm: { counter: 'asm_count', type: 'perl', lang: 'Assembly' },
      s: { counter: 'asm_count', type: 'perl', lang: 'Assembly' },
      ahk: { counter: 'autohotkey_count', type: 'perl', lang: 'AutoHotkey' },
      au3: { counter: 'autoit_count', type: 'perl', lang: 'AutoIt' },
      awk: { counter: 'awk_count', type: 'perl', lang: 'AWK' },
      bat: { counter: 'batch_count', type: 'perl', lang: 'Batch' },
      cmd: { counter: 'batch_count', type: 'perl', lang: 'Batch' },
      cob: { counter: 'cobol_count', type: 'perl', lang: 'COBOL' },
      cbl: { counter: 'cobol_count', type: 'perl', lang: 'COBOL' },
      cpy: { counter: 'cobol_count', type: 'perl', lang: 'COBOL' },
      csh: { counter: 'csh_count', type: 'perl', lang: 'C Shell' },
      tcsh: { counter: 'csh_count', type: 'perl', lang: 'C Shell' },
      exp: { counter: 'exp_count', type: 'perl', lang: 'Expect' },
      f: { counter: 'fortran_count', type: 'perl', lang: 'Fortran' },
      for: { counter: 'fortran_count', type: 'perl', lang: 'Fortran' },
      f77: { counter: 'fortran_count', type: 'perl', lang: 'Fortran' },
      f90: { counter: 'f90_count', type: 'perl', lang: 'Fortran 90+' },
      f95: { counter: 'f90_count', type: 'perl', lang: 'Fortran 90+' },
      f03: { counter: 'f90_count', type: 'perl', lang: 'Fortran 90+' },
      f08: { counter: 'f90_count', type: 'perl', lang: 'Fortran 90+' },
      hs: { counter: 'haskell_count', type: 'perl', lang: 'Haskell' },
      lhs: { counter: 'haskell_count', type: 'perl', lang: 'Haskell' },
      iss: { counter: 'innosetup_count', type: 'perl', lang: 'Inno Setup' },
      sh: { counter: 'sh_count', type: 'wasm', lang: 'Shell' },
      bash: { counter: 'sh_count', type: 'wasm', lang: 'Shell' },
      zsh: { counter: 'sh_count', type: 'wasm', lang: 'Shell' },
      js: { counter: 'javascript_count', type: 'wasm', lang: 'JavaScript' },
      mjs: { counter: 'javascript_count', type: 'wasm', lang: 'JavaScript' },
      cjs: { counter: 'javascript_count', type: 'wasm', lang: 'JavaScript' },
      ts: { counter: 'javascript_count', type: 'wasm', lang: 'TypeScript' },
      jsx: { counter: 'javascript_count', type: 'wasm', lang: 'JavaScript' },
      tsx: { counter: 'javascript_count', type: 'wasm', lang: 'TypeScript' },
      java: { counter: 'generic_count', type: 'wasm', lang: 'Java' },
      c: { counter: 'generic_count', type: 'wasm', lang: 'C' },
      h: { counter: 'generic_count', type: 'wasm', lang: 'C/C++' },
      cpp: { counter: 'generic_count', type: 'wasm', lang: 'C++' },
      cc: { counter: 'generic_count', type: 'wasm', lang: 'C++' },
      cxx: { counter: 'generic_count', type: 'wasm', lang: 'C++' },
      hpp: { counter: 'generic_count', type: 'wasm', lang: 'C++' },
      go: { counter: 'go_count', type: 'perl', lang: 'Go' },
      rs: { counter: 'rust_count', type: 'perl', lang: 'Rust' },
      php: { counter: 'php_count', type: 'wasm', lang: 'PHP' },
      phtml: { counter: 'php_count', type: 'wasm', lang: 'PHP' },
      sql: { counter: 'sql_count', type: 'perl', lang: 'SQL' },
      mk: { counter: 'makefile_count', type: 'perl', lang: 'Makefile' },
      lisp: { counter: 'lisp_count', type: 'perl', lang: 'Lisp' },
      lsp: { counter: 'lisp_count', type: 'perl', lang: 'Lisp' },
      cl: { counter: 'lisp_count', type: 'perl', lang: 'Lisp' },
      el: { counter: 'lisp_count', type: 'perl', lang: 'Lisp' },
      m3: { counter: 'modula3_count', type: 'perl', lang: 'Modula-3' },
      i3: { counter: 'modula3_count', type: 'perl', lang: 'Modula-3' },
      mg: { counter: 'modula3_count', type: 'perl', lang: 'Modula-3' },
      ig: { counter: 'modula3_count', type: 'perl', lang: 'Modula-3' },
      m: { counter: 'objc_count', type: 'perl', lang: 'Objective-C' },
      mm: { counter: 'objc_count', type: 'perl', lang: 'Objective-C++' },
      sed: { counter: 'sed_count', type: 'perl', lang: 'sed' },
      tcl: { counter: 'tcl_count', type: 'perl', lang: 'Tcl' },
      tk: { counter: 'tcl_count', type: 'perl', lang: 'Tcl' },
      vb: { counter: 'vbasic_count', type: 'perl', lang: 'Visual Basic' },
      bas: { counter: 'vbasic_count', type: 'perl', lang: 'Visual Basic' },
      frm: { counter: 'vbasic_count', type: 'perl', lang: 'Visual Basic' },
      cls: { counter: 'vbasic_count', type: 'perl', lang: 'Visual Basic' },
      ctl: { counter: 'vbasic_count', type: 'perl', lang: 'Visual Basic' },
      vbs: { counter: 'vbscript_count', type: 'perl', lang: 'VBScript' },
      json: { counter: 'javascript_count', type: 'wasm', lang: 'JavaScript' },
      jsonc: { counter: 'javascript_count', type: 'wasm', lang: 'JavaScript' },
      json5: { counter: 'javascript_count', type: 'wasm', lang: 'JavaScript' },
      yaml: { counter: 'generic_count', type: 'wasm', lang: DATA_CONFIG_BUCKET_LANG },
      yml: { counter: 'generic_count', type: 'wasm', lang: DATA_CONFIG_BUCKET_LANG },
      toml: { counter: 'generic_count', type: 'wasm', lang: DATA_CONFIG_BUCKET_LANG },
      ini: { counter: 'generic_count', type: 'wasm', lang: DATA_CONFIG_BUCKET_LANG },
      cfg: { counter: 'generic_count', type: 'wasm', lang: DATA_CONFIG_BUCKET_LANG },
      conf: { counter: 'generic_count', type: 'wasm', lang: DATA_CONFIG_BUCKET_LANG },
      config: { counter: 'generic_count', type: 'wasm', lang: DATA_CONFIG_BUCKET_LANG },
      properties: { counter: 'generic_count', type: 'wasm', lang: DATA_CONFIG_BUCKET_LANG },
      env: { counter: 'generic_count', type: 'wasm', lang: DATA_CONFIG_BUCKET_LANG },
      md: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      markdown: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      mdown: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      mkd: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      mkdn: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      mdtxt: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      mdtext: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      rmd: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      qmd: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      rst: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      rest: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      adoc: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      asciidoc: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      textile: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      org: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      pod: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      wiki: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      txt: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      text: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      nfo: { counter: 'generic_count', type: 'wasm', lang: DOC_BUCKET_LANG },
      swift: { counter: 'swift_count', type: 'perl', lang: 'Swift' },
      kt: { counter: 'kotlin_count', type: 'perl', lang: 'Kotlin' },
      kts: { counter: 'kotlin_count', type: 'perl', lang: 'Kotlin' },
      scala: { counter: 'scala_count', type: 'perl', lang: 'Scala' },
      dart: { counter: 'dart_count', type: 'perl', lang: 'Dart' },
      groovy: { counter: 'groovy_count', type: 'perl', lang: 'Groovy' },
      ex: { counter: 'elixir_count', type: 'perl', lang: 'Elixir' },
      exs: { counter: 'elixir_count', type: 'perl', lang: 'Elixir' },
      jl: { counter: 'julia_count', type: 'perl', lang: 'Julia' },
      fs: { counter: 'fsharp_count', type: 'perl', lang: 'F#' },
      fsx: { counter: 'fsharp_count', type: 'perl', lang: 'F#' },
      cs: { counter: 'generic_count', type: 'wasm', lang: 'C#' },
      html: { counter: 'generic_count', type: 'wasm', lang: 'HTML' },
      htm: { counter: 'generic_count', type: 'wasm', lang: 'HTML' },
      css: { counter: 'generic_count', type: 'wasm', lang: 'CSS' },
      xml: { counter: 'generic_count', type: 'wasm', lang: 'XML' },
      lua: { counter: 'generic_count', type: 'wasm', lang: 'Lua' },
      vim: { counter: 'generic_count', type: 'wasm', lang: 'Vim script' },
      y: { counter: 'lexcount1', type: 'wasm', lang: 'Yacc' },
      yacc: { counter: 'lexcount1', type: 'wasm', lang: 'Yacc' },
      l: { counter: 'lexcount1', type: 'wasm', lang: 'Lex' },
      lex: { counter: 'lexcount1', type: 'wasm', lang: 'Lex' },
      ml: { counter: 'ml_count', type: 'wasm', lang: 'OCaml' },
      mli: { counter: 'ml_count', type: 'wasm', lang: 'OCaml' },
      mll: { counter: 'ml_count', type: 'wasm', lang: 'OCaml' },
      mly: { counter: 'ml_count', type: 'wasm', lang: 'OCaml' },
      pig: { counter: 'pig_count', type: 'wasm', lang: 'Pig' }
    };

    const WASM_MODULE_CONFIG = {
      generic_count: { script: 'c_count.js', factory: 'createCCountModule' },
      php_count: { script: 'php_count.js', factory: 'createPhpCountModule' },
      lexcount1: { script: 'lexcount1.js', factory: 'createLexcount1Module' },
      ml_count: { script: 'ml_count.js', factory: 'createMlCountModule' },
      pig_count: { script: 'pig_count.js', factory: 'createPigCountModule' }
    };

    const cocomoConstantsByYear = {
      2000: { salary: 56286, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 172.200 },
      2001: { salary: 57888, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 177.100 },
      2002: { salary: 58803, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 179.900 },
      2003: { salary: 60143, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 184.000 },
      2004: { salary: 61745, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 188.900 },
      2005: { salary: 63828, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 195.300 },
      2006: { salary: 65883, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 201.600 },
      2007: { salary: 67760, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 207.342 },
      2008: { salary: 70362, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 215.303 },
      2009: { salary: 70112, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 214.537 },
      2010: { salary: 71277, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 218.056 },
      2011: { salary: 73528, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 224.939 },
      2012: { salary: 75050, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 229.594 },
      2013: { salary: 76149, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 232.957 },
      2014: { salary: 77384, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 236.736 },
      2015: { salary: 77476, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 237.017 },
      2016: { salary: 78453, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 240.007 },
      2017: { salary: 80124, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 245.120 },
      2018: { salary: 82081, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 251.107 },
      2019: { salary: 83569, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 255.657 },
      2020: { salary: 84600, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 258.811 },
      2021: { salary: 88574, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 270.970 },
      2022: { salary: 95663, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 292.655 },
      2023: { salary: 99599, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 304.702 },
      2024: { salary: 102540, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 313.689 },
      2025: { salary: 105232, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 321.943 },
      2026: { salary: 108178, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 330.957 },
      2027: { salary: 110774, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 338.900 },
      2028: { salary: 113322, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 346.695 },
      2029: { salary: 115929, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 354.669 },
      2030: { salary: 118595, overhead: 2.4, a: 2.4, b: 1.05, c: 2.5, d: 0.38, cpiU: 362.826 }
    };

    const COCOMO_MODE = {
      ORIGINAL: 'original',
      BY_FILE_YEAR: 'by-file-year',
      FORCE_YEAR: 'force-year'
    };

    const COCOMO_YEAR_MIN = 2000;
    const COCOMO_YEAR_MAX = 2030;
    const DEFAULT_COST_YEAR = Math.max(COCOMO_YEAR_MIN, Math.min(COCOMO_YEAR_MAX, new Date().getFullYear()));
    const COUNTER_BATCH_SIZE = 120;
    const DOCUMENT_BASENAMES = new Set([
      'readme',
      'changelog',
      'changes',
      'history',
      'license',
      'licence',
      'copying',
      'notice',
      'authors',
      'contributors',
      'contributing',
      'code_of_conduct',
      'security',
      'support',
      'roadmap',
      'faq',
      'notes',
      'release_notes',
      'todo'
    ]);

    const statusEl = document.getElementById('status');
    const resultsEl = document.getElementById('results');
    const languageBody = document.getElementById('languageTableBody');
    const analyzePasteBtn = document.getElementById('analyzePasteBtn');
    const analyzeGithubBtn = document.getElementById('analyzeGithubBtn');
    const analyzeZipBtn = document.getElementById('analyzeZipBtn');
    const loadedCountersEl = document.getElementById('loadedCounters');
    const cocomoModeInput = document.getElementById('cocomoModeInput');
    const forceYearInput = document.getElementById('forceYearInput');
    const cocomoModeNote = document.getElementById('cocomoModeNote');
    const yearCostBody = document.getElementById('yearCostBody');
    const unmappedTypeBody = document.getElementById('unmappedTypeBody');
    const unmappedTypeCount = document.getElementById('unmappedTypeCount');

    let lastSummary = null;
    let currentFiles = [];
    let lastUnmappedTypes = [];
    let perlReady = false;
    let slocScripts = {};
    let wasmModules = {};

    analyzePasteBtn.disabled = true;
    analyzeGithubBtn.disabled = true;
    analyzeZipBtn.disabled = true;

    const LOCAL_SERVER_COMMAND = 'python3 -m http.server 4000';

    function normalizeYear(year) {
      const value = Number(year);
      if (!Number.isFinite(value)) return null;
      return Math.max(COCOMO_YEAR_MIN, Math.min(COCOMO_YEAR_MAX, Math.floor(value)));
    }

    function inferYearFromPath(path) {
      if (!path) return null;
      const directMatch = path.match(/(?:^|[^\d])(19\d{2}|20\d{2})(?:[^\d]|$)/);
      if (!directMatch) return null;
      return normalizeYear(Number(directMatch[1]));
    }

    function cocomoConstantsForYear(year) {
      const normalized = normalizeYear(year) || DEFAULT_COST_YEAR;
      return cocomoConstantsByYear[normalized] || cocomoConstantsByYear[DEFAULT_COST_YEAR];
    }

    function populateYearSelect() {
      forceYearInput.innerHTML = '';
      for (let year = COCOMO_YEAR_MAX; year >= COCOMO_YEAR_MIN; year -= 1) {
        const option = document.createElement('option');
        option.value = String(year);
        option.textContent = String(year);
        if (year === normalizeYear(DEFAULT_COST_YEAR)) option.selected = true;
        forceYearInput.appendChild(option);
      }
    }

    function syncCocomoControls() {
      const mode = cocomoModeInput.value;
      const manualInputs = ['salaryInput', 'overheadInput', 'aInput', 'bInput', 'cInput', 'dInput'];
      const manualEnabled = mode === COCOMO_MODE.ORIGINAL;
      for (const inputId of manualInputs) {
        const input = document.getElementById(inputId);
        input.disabled = !manualEnabled;
      }
      forceYearInput.disabled = mode !== COCOMO_MODE.FORCE_YEAR;

      if (mode === COCOMO_MODE.BY_FILE_YEAR) {
        cocomoModeNote.textContent = 'Mode: By file created year using annual constants (default).';
      } else if (mode === COCOMO_MODE.FORCE_YEAR) {
        cocomoModeNote.textContent = `Mode: Forced year ${forceYearInput.value} for all files.`;
      } else {
        cocomoModeNote.textContent = 'Mode: Original formula using manual constants.';
      }
    }

    function setStatus(message, type = 'secondary', allowHtml = false) {
      statusEl.className = `alert alert-${type}`;
      if (allowHtml) {
        statusEl.innerHTML = message;
      } else {
        statusEl.textContent = message;
      }
    }

    function showFileProtocolWarning() {
      setStatus(
        'This tool cannot run via file:// due to browser security limits for WebAssembly/data fetches.' +
        '<div class="mt-2 d-flex flex-wrap gap-2 align-items-center">' +
        '<button id="copyLocalServeCmd" type="button" class="btn btn-sm btn-outline-dark">Copy local server command</button>' +
        '<span class="small">Then open <code>http://localhost:4000/tools/sloccount-web-analyzer.html</code></span>' +
        '</div>',
        'warning',
        true
      );

      const copyBtn = document.getElementById('copyLocalServeCmd');
      if (!copyBtn) return;

      copyBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(LOCAL_SERVER_COMMAND);
          const original = copyBtn.textContent;
          copyBtn.textContent = 'Copied';
          setTimeout(() => {
            copyBtn.textContent = original;
          }, 1200);
        } catch {
          setStatus(`Run this in repo root: ${LOCAL_SERVER_COMMAND}`, 'warning');
        }
      });
    }

    function setTab(tabId) {
      const mapping = [
        { btn: 'paste-tab', pane: 'paste-pane' },
        { btn: 'github-tab', pane: 'github-pane' },
        { btn: 'zip-tab', pane: 'zip-pane' }
      ];
      for (const { btn, pane } of mapping) {
        const isActive = btn === tabId;
        document.getElementById(btn).classList.toggle('active', isActive);
        const paneEl = document.getElementById(pane);
        paneEl.classList.toggle('show', isActive);
        paneEl.classList.toggle('active', isActive);
      }
    }

    document.getElementById('paste-tab').addEventListener('click', () => setTab('paste-tab'));
    document.getElementById('github-tab').addEventListener('click', () => setTab('github-tab'));
    document.getElementById('zip-tab').addEventListener('click', () => setTab('zip-tab'));

    function parseRepoInput(input) {
      const trimmed = (input || '').trim();
      if (!trimmed) return null;
      const urlMatch = trimmed.match(/^https?:\/\/github\.com\/([^\/]+)\/([^\/\s#?]+)/i);
      if (urlMatch) return { owner: urlMatch[1], repo: urlMatch[2].replace(/\.git$/i, '') };
      const shortMatch = trimmed.match(/^([^\/\s]+)\/([^\/\s]+)$/);
      if (shortMatch) return { owner: shortMatch[1], repo: shortMatch[2].replace(/\.git$/i, '') };
      return null;
    }

    function extensionFor(filePath) {
      const lower = (filePath || '').toLowerCase();
      if (!lower) return null;
      if (lower.endsWith('/dockerfile') || lower === 'dockerfile') return 'sh';
      const leaf = lower.split('/').pop();
      const leafNoExt = leaf.replace(/\.[^.]*$/, '');
      if (leaf === 'makefile' || leaf === 'gnumakefile' || leaf === 'bsdmakefile') return 'mk';
      if (leaf.startsWith('makefile.')) return 'mk';
      if (DOCUMENT_BASENAMES.has(leaf) || DOCUMENT_BASENAMES.has(leafNoExt)) return 'md';
      const idx = lower.lastIndexOf('.');
      if (idx === -1) return null;
      return lower.slice(idx + 1);
    }

    function isSupportedSourceFile(filePath) {
      const ext = extensionFor(filePath);
      return !!(ext && COUNTER_MAP[ext]);
    }

    function describeUnmappedType(filePath) {
      const lower = (filePath || '').toLowerCase();
      const leaf = lower.split('/').pop() || lower;
      const idx = leaf.lastIndexOf('.');
      if (idx !== -1 && idx < leaf.length - 1) {
        return `.${leaf.slice(idx + 1)}`;
      }
      return '(no extension)';
    }

    function collectUnmappedTypes(paths) {
      const map = {};
      for (const path of paths) {
        if (isSupportedSourceFile(path)) continue;
        const type = describeUnmappedType(path);
        if (!map[type]) {
          map[type] = { type, count: 0, sample: path };
        }
        map[type].count += 1;
      }
      return Object.values(map).sort((a, b) => b.count - a.count || a.type.localeCompare(b.type));
    }

    function renderUnmappedTypes(rows) {
      lastUnmappedTypes = rows || [];
      unmappedTypeCount.textContent = String(lastUnmappedTypes.length);
      unmappedTypeBody.innerHTML = '';
      if (!lastUnmappedTypes.length) {
        unmappedTypeBody.innerHTML = '<tr><td colspan="3" class="text-body-secondary">No unmapped file types in this input.</td></tr>';
        return;
      }

      for (const row of lastUnmappedTypes) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${row.type}</td><td class="text-end">${row.count.toLocaleString()}</td><td class="mono">${row.sample}</td>`;
        unmappedTypeBody.appendChild(tr);
      }
    }

    function loadScript(url, parentTag = 'head') {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = url;
        script.async = false;
        script.defer = false;
        script.onload = resolve;
        script.onerror = reject;
        const parent = parentTag === 'body' ? document.body : document.head;
        parent.appendChild(script);
      });
    }

    async function loadWebPerl() {
      if (window.Perl) return;
      await loadScript('./lib/webperl/webperl.js', 'body');
    }

    async function loadJsZip() {
      if (window.JSZip) return window.JSZip;
      await loadScript('./lib/vendor/jszip.min.js');
      return window.JSZip;
    }

    function parseCounterOutput(output, pathMeta = {}) {
      const lines = (output || '').split('\n');
      let groupLines = 0;
      let groupFiles = 0;
      const fileResults = [];
      for (const line of lines) {
        if (!line.trim() || line.startsWith('Total:')) continue;
        const match = line.match(/^(\d+)\s+(.+)$/);
        if (match) {
          const fileLines = parseInt(match[1], 10);
          const rawPath = (match[2] || '').trim();
          const meta = pathMeta[rawPath] || { filename: rawPath, createdYear: null, createdYearSource: 'unknown' };
          groupLines += fileLines;
          groupFiles += 1;
          fileResults.push({
            filename: meta.filename,
            lines: fileLines,
            createdYear: normalizeYear(meta.createdYear),
            createdYearSource: meta.createdYearSource || 'unknown'
          });
        }
      }
      return { groupLines, groupFiles, fileResults };
    }

    async function initializeWebAssemblyEngine() {
      try {
        setStatus('Loading WebAssembly runtime...', 'info');
        if (window.location.protocol === 'file:') {
          if (loadedCountersEl) {
            loadedCountersEl.textContent = 'Loaded counters: unavailable in file:// mode';
          }
          showFileProtocolWarning();
          return;
        }

        await loadJsZip();
        await loadWebPerl();

        while (!(window.Perl && Perl.state === 'Running')) {
          await new Promise((resolve) => setTimeout(resolve, 100));
        }

        setStatus('Loading SLOCCount scripts...', 'info');
        const zipRes = await fetch(`${SLOC_ASSET_BASE}/sloccount-perl.zip`);
        if (!zipRes.ok) throw new Error('Unable to fetch sloccount-perl.zip');
        const zipBlob = await zipRes.blob();
        const zip = await JSZip.loadAsync(zipBlob);

        const scriptsToLoad = [
          'python_count', 'perl_count', 'ruby_count', 'generic_count',
          'javascript_count', 'sh_count', 'sql_count', 'lisp_count',
          'asm_count', 'ada_count', 'awk_count', 'cobol_count', 'fortran_count',
          'f90_count', 'haskell_count', 'makefile_count', 'modula3_count',
          'objc_count', 'sed_count', 'tcl_count', 'vbasic_count', 'exp_count',
          'csh_count', 'batch_count', 'vbscript_count', 'autohotkey_count',
          'autoit_count', 'innosetup_count', 'lex_count'
        ];

        for (const scriptName of scriptsToLoad) {
          if (zip.files[scriptName]) {
            slocScripts[scriptName] = await zip.files[scriptName].async('text');
          }
        }

        const modernScripts = [
          'kotlin_count', 'swift_count', 'dart_count', 'scala_count',
          'groovy_count', 'elixir_count', 'julia_count', 'fsharp_count',
          'rust_count', 'go_count'
        ];

        for (const scriptName of modernScripts) {
          try {
            const response = await fetch(`${SLOC_ASSET_BASE}/sloc/${scriptName}`);
            if (response.ok) slocScripts[scriptName] = await response.text();
          } catch {
            // Skip optional scripts that fail to load
          }
        }

        window.counterScripts = slocScripts;
        window.wasmOutput = [];

        const requiredWasmCounters = [...new Set(
          Object.values(COUNTER_MAP)
            .filter((entry) => entry.type === 'wasm')
            .map((entry) => entry.counter)
        )];

        setStatus('Loading WebAssembly counters...', 'info');
        for (const counterName of requiredWasmCounters) {
          const config = WASM_MODULE_CONFIG[counterName];
          if (!config) continue;
          await loadScript(`${SLOC_ASSET_BASE}/wasm/${config.script}`);
          const factory = window[config.factory];
          if (typeof factory !== 'function') {
            throw new Error(`Missing WASM factory: ${config.factory}`);
          }
          wasmModules[counterName] = await factory({
            print: (text) => { window.wasmOutput.push(text); },
            printErr: () => {},
            noInitialRun: true,
            locateFile: (path) => `${SLOC_ASSET_BASE}/wasm/${path}`
          });
        }

        const loadedCounters = Object.keys(wasmModules).sort();
        if (loadedCountersEl) {
          loadedCountersEl.textContent = `Loaded counters: ${loadedCounters.join(', ')}`;
        }
        const counterSummary = loadedCounters.length ? loadedCounters.join(', ') : 'none';

        perlReady = true;
        analyzePasteBtn.disabled = false;
        analyzeGithubBtn.disabled = false;
        analyzeZipBtn.disabled = false;
        setStatus(`WebAssembly SLOCCount ready. Loaded counters: ${counterSummary}`, 'success');
      } catch (error) {
        if (loadedCountersEl) {
          loadedCountersEl.textContent = 'Loaded counters: failed to initialize';
        }
        setStatus(`Failed to initialize WebAssembly engine: ${error.message}. Loaded counters: failed`, 'danger');
      }
    }

    async function runSloccount(files) {
      if (!perlReady) throw new Error('WASM engine is not ready yet.');

      const filesByCounter = {};
      for (const file of files) {
        if (!file || typeof file.content !== 'string' || file.content.includes('\u0000')) continue;
        const ext = extensionFor(file.filename || file.path);
        const counterInfo = ext ? COUNTER_MAP[ext] : null;
        if (!counterInfo) continue;

        const key = `${counterInfo.type}:${counterInfo.counter}:${counterInfo.lang}`;
        if (!filesByCounter[key]) {
          filesByCounter[key] = {
            type: counterInfo.type,
            counter: counterInfo.counter,
            lang: counterInfo.lang,
            files: []
          };
        }
        filesByCounter[key].files.push({
          filename: file.filename || file.path,
          content: file.content,
          createdYear: normalizeYear(file.createdYear),
          createdYearSource: file.createdYearSource || 'unknown'
        });
      }

      const langStats = {};
      let totalLines = 0;
      const fileStats = [];

      for (const key of Object.keys(filesByCounter)) {
        const group = filesByCounter[key];
        let parsed = { groupLines: 0, groupFiles: 0, fileResults: [] };

        if (group.type === 'perl') {
          const script = window.counterScripts[group.counter];
          if (!script) continue;

          for (let offset = 0; offset < group.files.length; offset += COUNTER_BATCH_SIZE) {
            const batchFiles = group.files.slice(offset, offset + COUNTER_BATCH_SIZE);
            const filePaths = [];
            const pathMeta = {};
            for (let i = 0; i < batchFiles.length; i += 1) {
              const file = batchFiles[i];
              const sanitized = file.filename.replace(/[^a-zA-Z0-9._\/-]/g, '_').split('/').pop();
              const path = `/tmp/${Date.now()}_${offset + i}_${sanitized}`;
              window._tempFileContent = file.content;
              Perl.eval(`
                use WebPerl qw/js/;
                my $path = '${path}';
                my $content = js('window')->{_tempFileContent};
                open(my $fh, '>', $path) or die "Cannot write $path: $!";
                print $fh $content;
                close($fh);
              `);
              filePaths.push(path);
              pathMeta[path] = {
                filename: file.filename,
                createdYear: file.createdYear,
                createdYearSource: file.createdYearSource
              };
            }
            window._tempFileContent = null;

            window.perlCounterOutput = '';
            Perl.eval(`
              use warnings;
              use WebPerl qw/js/;
              my $script = js('window')->{counterScripts}{'${group.counter}'};
              @ARGV = (${filePaths.map((p) => `'${p}'`).join(', ')});
              my $output = '';
              open(my $stdout_fh, '>', \\\$output) or die "Cannot redirect: $!";
              select $stdout_fh;
              eval $script;
              if ($@) { $output .= "ERROR: $@"; }
              select STDOUT;
              close($stdout_fh);
              js('window')->{perlCounterOutput} = $output;
            `);

            const batchParsed = parseCounterOutput(window.perlCounterOutput, pathMeta);
            parsed.groupLines += batchParsed.groupLines;
            parsed.groupFiles += batchParsed.groupFiles;
            parsed.fileResults.push(...batchParsed.fileResults);
          }
        }

        if (group.type === 'wasm') {
          const module = wasmModules[group.counter] || wasmModules.generic_count;
          if (!module) continue;
          for (let offset = 0; offset < group.files.length; offset += COUNTER_BATCH_SIZE) {
            const batchFiles = group.files.slice(offset, offset + COUNTER_BATCH_SIZE);
            const filePaths = [];
            const pathMeta = {};

            for (let i = 0; i < batchFiles.length; i += 1) {
              const file = batchFiles[i];
              const sanitized = file.filename.replace(/[^a-zA-Z0-9._\/-]/g, '_').split('/').pop();
              const path = `/tmp/${Date.now()}_${offset + i}_${sanitized}`;
              module.FS.writeFile(path, file.content);
              filePaths.push(path);
              pathMeta[path] = {
                filename: file.filename,
                createdYear: file.createdYear,
                createdYearSource: file.createdYearSource
              };
            }

            window.wasmOutput = [];
            module.callMain(filePaths);
            const batchParsed = parseCounterOutput(window.wasmOutput.join('\n'), pathMeta);
            parsed.groupLines += batchParsed.groupLines;
            parsed.groupFiles += batchParsed.groupFiles;
            parsed.fileResults.push(...batchParsed.fileResults);
          }
        }

        if (!langStats[group.lang]) {
          langStats[group.lang] = { language: group.lang, lines: 0, files: 0 };
        }
        langStats[group.lang].lines += parsed.groupLines;
        langStats[group.lang].files += parsed.groupFiles;
        totalLines += parsed.groupLines;
        for (const fileStat of parsed.fileResults) {
          fileStats.push(fileStat);
        }
      }

      const languages = Object.values(langStats).sort((a, b) => b.lines - a.lines);
      const totalFiles = languages.reduce((acc, row) => acc + row.files, 0);

      return {
        totalLines,
        totalFiles,
        totalLanguages: languages.length,
        languages,
        fileStats
      };
    }

    function computeSingleCocomo(lines, constants) {
      const kloc = lines / 1000;
      const effortPM = kloc > 0 ? constants.a * Math.pow(kloc, constants.b) : 0;
      const scheduleMonths = effortPM > 0 ? constants.c * Math.pow(effortPM, constants.d) : 0;
      const personYears = effortPM / 12;
      const annualLoaded = constants.salary * constants.overhead;
      const cost = personYears * annualLoaded;
      return { effortPM, scheduleMonths, personYears, cost };
    }

    function renderYearBreakdown(yearRows) {
      yearCostBody.innerHTML = '';
      if (!yearRows.length) {
        yearCostBody.innerHTML = '<tr><td colspan="4" class="text-body-secondary">No per-year data available.</td></tr>';
        return;
      }
      for (const row of yearRows) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${row.year}</td><td class="text-end">${row.files.toLocaleString()}</td><td class="text-end">${row.lines.toLocaleString()}</td><td class="text-end">$${Math.round(row.cost).toLocaleString()}</td>`;
        yearCostBody.appendChild(tr);
      }
    }

    function computeCocomo(summary) {
      const mode = cocomoModeInput.value;

      if (mode === COCOMO_MODE.ORIGINAL) {
        const constants = {
          salary: Number(document.getElementById('salaryInput').value || 56286),
          overhead: Number(document.getElementById('overheadInput').value || 2.4),
          a: Number(document.getElementById('aInput').value || 2.4),
          b: Number(document.getElementById('bInput').value || 1.05),
          c: Number(document.getElementById('cInput').value || 2.5),
          d: Number(document.getElementById('dInput').value || 0.38)
        };
        const value = computeSingleCocomo(summary.totalLines, constants);
        renderYearBreakdown([]);
        return { ...value, mode, unknownYearFiles: 0 };
      }

      const forceYear = normalizeYear(forceYearInput.value) || DEFAULT_COST_YEAR;
      const files = summary.fileStats || [];
      const yearMap = {};
      let totalEffortPM = 0;
      let totalScheduleMonths = 0;
      let totalPersonYears = 0;
      let totalCost = 0;
      let unknownYearFiles = 0;

      for (const file of files) {
        if (!file.lines) continue;
        let year = null;
        if (mode === COCOMO_MODE.FORCE_YEAR) {
          year = forceYear;
        } else {
          year = normalizeYear(file.createdYear);
          if (!year) {
            year = DEFAULT_COST_YEAR;
            unknownYearFiles += 1;
          }
        }

        const constants = cocomoConstantsForYear(year);
        const value = computeSingleCocomo(file.lines, constants);

        if (!yearMap[year]) {
          yearMap[year] = { year, files: 0, lines: 0, cost: 0 };
        }
        yearMap[year].files += 1;
        yearMap[year].lines += file.lines;
        yearMap[year].cost += value.cost;

        totalEffortPM += value.effortPM;
        totalScheduleMonths += value.scheduleMonths;
        totalPersonYears += value.personYears;
        totalCost += value.cost;
      }

      const yearRows = Object.values(yearMap).sort((a, b) => a.year - b.year);
      renderYearBreakdown(yearRows);

      return {
        effortPM: totalEffortPM,
        scheduleMonths: totalScheduleMonths,
        personYears: totalPersonYears,
        cost: totalCost,
        mode,
        unknownYearFiles
      };
    }

    function renderResults(summary, sourceLabel) {
      lastSummary = summary;
      const cocomo = computeCocomo(summary);

      document.getElementById('totalLines').textContent = summary.totalLines.toLocaleString();
      document.getElementById('totalLanguages').textContent = summary.totalLanguages.toLocaleString();
      document.getElementById('totalFiles').textContent = summary.totalFiles.toLocaleString();
      document.getElementById('personYears').textContent = cocomo.personYears.toFixed(2);
      document.getElementById('estCost').textContent = `$${Math.round(cocomo.cost).toLocaleString()}`;
      document.getElementById('analyzedSource').textContent = sourceLabel;
      renderUnmappedTypes(summary.unmappedTypes || []);

      if (cocomo.mode === COCOMO_MODE.BY_FILE_YEAR && cocomo.unknownYearFiles > 0) {
        setStatus(`Analysis complete. ${cocomo.unknownYearFiles} file(s) had unknown created year and defaulted to ${DEFAULT_COST_YEAR}.`, 'warning');
      }

      languageBody.innerHTML = '';
      for (const row of summary.languages) {
        const percent = summary.totalLines ? ((row.lines / summary.totalLines) * 100) : 0;
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${row.language}</td><td class="text-end">${row.lines.toLocaleString()}</td><td class="text-end">${percent.toFixed(1)}%</td><td class="text-end">${row.files.toLocaleString()}</td>`;
        languageBody.appendChild(tr);
      }

      resultsEl.classList.remove('d-none');
    }

    function announceAnalysisCompletion(summary, suffix = '') {
      if (!summary) return;
      const mode = cocomoModeInput.value;
      if (mode === COCOMO_MODE.BY_FILE_YEAR) {
        const unknownCount = (summary.fileStats || []).filter((file) => !normalizeYear(file.createdYear)).length;
        if (unknownCount > 0) {
          setStatus(`Analysis complete${suffix}. ${unknownCount} file(s) had unknown created year and defaulted to ${DEFAULT_COST_YEAR}.`, 'warning');
          return;
        }
      }
      setStatus(`Analysis complete${suffix}.`, 'success');
    }

    async function analyzePaste() {
      const filename = document.getElementById('pasteFilename').value.trim();
      const code = document.getElementById('pasteCode').value;
      if (!filename) { setStatus('Filename is required for paste mode.', 'danger'); return; }
      if (!code.trim()) { setStatus('Code is required for paste mode.', 'danger'); return; }
      if (!isSupportedSourceFile(filename)) {
        setStatus('Unsupported filename extension for SLOCCount analysis.', 'warning');
        renderUnmappedTypes([{ type: describeUnmappedType(filename), count: 1, sample: filename }]);
        return;
      }

      setStatus('Analyzing pasted code with WebAssembly SLOCCount...', 'info');
      const inferredYear = inferYearFromPath(filename);
      const summary = await runSloccount([{
        filename,
        content: code,
        createdYear: inferredYear,
        createdYearSource: inferredYear ? 'filename' : 'unknown'
      }]);
      summary.unmappedTypes = [];
      if (summary.totalFiles === 0) {
        setStatus('No recognized code files from pasted input.', 'warning');
        return;
      }
      currentFiles = [{ filename, content: code, createdYear: inferredYear }];
      renderResults(summary, 'Paste Code');
      announceAnalysisCompletion(summary);
    }

    async function analyzeGithub() {
      const parsed = parseRepoInput(document.getElementById('githubRepo').value);
      const refInput = document.getElementById('githubRef').value.trim();
      if (!parsed) { setStatus('Enter a valid GitHub repository: owner/repo or full URL.', 'danger'); return; }

      const { owner, repo } = parsed;
      setStatus(`Fetching repository metadata for ${owner}/${repo}...`, 'info');

      const repoRes = await fetch(`https://api.github.com/repos/${owner}/${repo}`);
      if (repoRes.status === 404) { setStatus('Repository not found.', 'danger'); return; }
      if (repoRes.status === 403) { setStatus('GitHub API rate limited. Retry later or use ZIP mode.', 'warning'); return; }
      if (!repoRes.ok) { setStatus(`GitHub error (${repoRes.status}).`, 'danger'); return; }

      const repoJson = await repoRes.json();
      const ref = refInput || repoJson.default_branch;
      setStatus(`Fetching file tree for ref '${ref}'...`, 'info');

      const treeRes = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees/${encodeURIComponent(ref)}?recursive=1`);
      if (treeRes.status === 404) { setStatus('Branch/ref not found.', 'danger'); return; }
      if (!treeRes.ok) { setStatus(`Unable to read repository tree (${treeRes.status}).`, 'danger'); return; }

      const treeJson = await treeRes.json();
      if (treeJson.truncated) {
        setStatus('Repository tree is too large (truncated). Please use ZIP mode.', 'warning');
        return;
      }

      const paths = (treeJson.tree || [])
        .filter((n) => n.type === 'blob')
        .map((n) => n.path);

      const unmappedTypes = collectUnmappedTypes(paths);
      const analyzablePaths = paths.filter((p) => isSupportedSourceFile(p));

      if (analyzablePaths.length === 0) {
        renderUnmappedTypes(unmappedTypes);
        setStatus('No recognized code files found in repository.', 'warning');
        return;
      }

      const files = [];
      const batchSize = 8;
      for (let i = 0; i < analyzablePaths.length; i += batchSize) {
        const batch = analyzablePaths.slice(i, i + batchSize);
        setStatus(`Downloading files ${i + 1}-${Math.min(i + batch.length, analyzablePaths.length)} of ${analyzablePaths.length}...`, 'info');
        const chunks = await Promise.all(batch.map(async (path) => {
          const rawUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${ref}/${path}`;
          try {
            const r = await fetch(rawUrl);
            if (!r.ok) return null;
            const content = await r.text();
            const inferredYear = inferYearFromPath(path);
            return {
              filename: path,
              content,
              createdYear: inferredYear,
              createdYearSource: inferredYear ? 'filename' : 'unknown'
            };
          } catch {
            return null;
          }
        }));
        for (const f of chunks) if (f) files.push(f);
      }

      if (files.length === 0) { setStatus('Unable to download analyzable files. Try ZIP mode.', 'danger'); return; }

      setStatus(`Running WebAssembly SLOCCount on ${files.length} files...`, 'info');
      const summary = await runSloccount(files);
      summary.unmappedTypes = unmappedTypes;
      currentFiles = files;
      renderResults(summary, `GitHub: ${owner}/${repo}@${ref}`);
      announceAnalysisCompletion(summary, `. Processed ${summary.totalFiles} files`);
    }

    async function analyzeZip() {
      const input = document.getElementById('zipFile');
      const file = input.files?.[0];
      if (!file) { setStatus('Choose a .zip file first.', 'danger'); return; }
      if (!file.name.toLowerCase().endsWith('.zip')) { setStatus('Only .zip files are supported.', 'danger'); return; }

      setStatus('Loading ZIP parser...', 'info');
      let JSZip;
      try {
        JSZip = await loadJsZip();
      } catch {
        setStatus('Unable to load ZIP parser. Check connection and retry.', 'danger');
        return;
      }

      setStatus('Reading ZIP archive...', 'info');
      const zip = await JSZip.loadAsync(file);
      const allEntries = Object.values(zip.files).filter((z) => !z.dir);
      const unmappedTypes = collectUnmappedTypes(allEntries.map((z) => z.name));
      const entries = allEntries.filter((z) => isSupportedSourceFile(z.name));
      if (entries.length === 0) {
        renderUnmappedTypes(unmappedTypes);
        setStatus('No recognized code files found in ZIP.', 'warning');
        return;
      }

      const files = [];
      let processed = 0;
      for (const entry of entries) {
        processed += 1;
        setStatus(`Extracting ${processed}/${entries.length}: ${entry.name}`, 'info');
        try {
          const content = await entry.async('string');
          const zipYear = entry.date instanceof Date ? normalizeYear(entry.date.getUTCFullYear()) : null;
          const inferredYear = zipYear || inferYearFromPath(entry.name);
          files.push({
            filename: entry.name,
            content,
            createdYear: inferredYear,
            createdYearSource: zipYear ? 'zip-entry-date' : (inferredYear ? 'filename' : 'unknown')
          });
        } catch {
          // Skip unreadable files
        }
      }

      if (!files.length) { setStatus('ZIP parsed, but no readable source files were extracted.', 'danger'); return; }
      setStatus(`Running WebAssembly SLOCCount on ${files.length} files...`, 'info');
      const summary = await runSloccount(files);
      summary.unmappedTypes = unmappedTypes;
      currentFiles = files;
      renderResults(summary, `ZIP: ${file.name}`);
      announceAnalysisCompletion(summary, `. Processed ${summary.totalFiles} files from ZIP`);
    }

    document.getElementById('analyzePasteBtn').addEventListener('click', () => analyzePaste().catch((e) => setStatus(`Paste analysis failed: ${e.message}`, 'danger')));
    document.getElementById('analyzeGithubBtn').addEventListener('click', () => analyzeGithub().catch((e) => setStatus(`GitHub analysis failed: ${e.message}`, 'danger')));
    document.getElementById('analyzeZipBtn').addEventListener('click', () => analyzeZip().catch((e) => setStatus(`ZIP analysis failed: ${e.message}`, 'danger')));

    document.getElementById('recalcBtn').addEventListener('click', () => {
      if (!lastSummary) {
        setStatus('Run an analysis first, then recalculate.', 'warning');
        return;
      }
      if (!lastSummary.unmappedTypes) {
        lastSummary.unmappedTypes = lastUnmappedTypes;
      }
      renderResults(lastSummary, document.getElementById('analyzedSource').textContent || 'Analysis');
      setStatus('Cost model recalculated.', 'success');
    });

    cocomoModeInput.addEventListener('change', () => {
      syncCocomoControls();
      if (lastSummary) {
        renderResults(lastSummary, document.getElementById('analyzedSource').textContent || 'Analysis');
      }
    });

    forceYearInput.addEventListener('change', () => {
      syncCocomoControls();
      if (cocomoModeInput.value === COCOMO_MODE.FORCE_YEAR && lastSummary) {
        renderResults(lastSummary, document.getElementById('analyzedSource').textContent || 'Analysis');
      }
    });

    document.getElementById('githubRepo').addEventListener('keypress', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        if (!analyzeGithubBtn.disabled) analyzeGithub().catch((e) => setStatus(`GitHub analysis failed: ${e.message}`, 'danger'));
      }
    });

    populateYearSelect();
    cocomoModeInput.value = COCOMO_MODE.BY_FILE_YEAR;
    syncCocomoControls();

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeWebAssemblyEngine, { once: true });
    } else {
      initializeWebAssemblyEngine();
    }
  </script>
  <script type="text/perl">
    1;
  </script>
</body>
</html>
