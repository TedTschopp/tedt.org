<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SLOCCount Web Analyzer</title>
  <meta name="description" content="Analyze source code in the browser for SLOC and rough COCOMO cost estimates.">
  <link rel="icon" href="../favicon.ico" sizes="any">
  <link rel="stylesheet" href="../css/bootstrap-build.css">
  <link rel="stylesheet" href="../css/consolidated-fonts.css">
  <style>
    body { background: var(--bs-body-bg); }
    .app-wrap { max-width: 1120px; }
    .muted-note { color: var(--bs-secondary-color); font-size: 0.9rem; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .table-fixed th, .table-fixed td { vertical-align: middle; }
  </style>
</head>
<body>
  <main class="container app-wrap py-4">
    <div class="mb-3">
      <h1 class="h2 mb-1">SLOCCount Web Analyzer</h1>
      <p class="mb-0 muted-note">Client-side Source Lines of Code analysis with rough Basic COCOMO cost and effort estimates.</p>
      <p id="loadedCounters" class="mb-0 mt-1 muted-note">Loaded counters: initializing…</p>
    </div>

    <div id="status" class="alert alert-secondary" role="status" aria-live="polite">Ready.</div>

    <ul class="nav nav-pills mb-3" id="inputTabs" role="tablist">
      <li class="nav-item" role="presentation"><button class="nav-link active" id="paste-tab" data-bs-toggle="pill" data-bs-target="#paste-pane" type="button" role="tab">Paste Code</button></li>
      <li class="nav-item" role="presentation"><button class="nav-link" id="github-tab" data-bs-toggle="pill" data-bs-target="#github-pane" type="button" role="tab">GitHub Repository</button></li>
      <li class="nav-item" role="presentation"><button class="nav-link" id="zip-tab" data-bs-toggle="pill" data-bs-target="#zip-pane" type="button" role="tab">Upload ZIP</button></li>
    </ul>

    <div class="tab-content">
      <section class="tab-pane fade show active" id="paste-pane" role="tabpanel" aria-labelledby="paste-tab">
        <div class="card mb-3">
          <div class="card-body">
            <div class="row g-3">
              <div class="col-md-4">
                <label for="pasteFilename" class="form-label">Filename</label>
                <input id="pasteFilename" class="form-control" placeholder="example.py">
              </div>
              <div class="col-12">
                <label for="pasteCode" class="form-label">Code</label>
                <textarea id="pasteCode" class="form-control mono" rows="14" placeholder="Paste source code here..."></textarea>
              </div>
            </div>
            <button id="analyzePasteBtn" class="btn btn-primary mt-3">Analyze</button>
          </div>
        </div>
      </section>

      <section class="tab-pane fade" id="github-pane" role="tabpanel" aria-labelledby="github-tab">
        <div class="card mb-3">
          <div class="card-body">
            <div class="row g-3">
              <div class="col-lg-8">
                <label for="githubRepo" class="form-label">Repository</label>
                <input id="githubRepo" class="form-control" placeholder="owner/repo or https://github.com/owner/repo">
              </div>
              <div class="col-lg-4">
                <label for="githubRef" class="form-label">Branch / Ref (optional)</label>
                <input id="githubRef" class="form-control" placeholder="main">
              </div>
            </div>
            <p class="muted-note mt-2 mb-0">Public repositories only. For very large repos, ZIP mode is more reliable.</p>
            <button id="analyzeGithubBtn" class="btn btn-primary mt-3">Analyze Repository</button>
          </div>
        </div>
      </section>

      <section class="tab-pane fade" id="zip-pane" role="tabpanel" aria-labelledby="zip-tab">
        <div class="card mb-3">
          <div class="card-body">
            <label for="zipFile" class="form-label">ZIP Archive</label>
            <input id="zipFile" class="form-control" type="file" accept=".zip,application/zip">
            <p class="muted-note mt-2 mb-0">All analysis happens in your browser. ZIP processing uses JSZip loaded on demand.</p>
            <button id="analyzeZipBtn" class="btn btn-primary mt-3">Analyze ZIP</button>
          </div>
        </div>
      </section>
    </div>

    <section id="results" class="d-none">
      <div class="row g-3 mb-3">
        <div class="col-6 col-md-2"><div class="card"><div class="card-body"><div class="text-secondary small">Total Lines</div><div id="totalLines" class="h4 mb-0">0</div></div></div></div>
        <div class="col-6 col-md-2"><div class="card"><div class="card-body"><div class="text-secondary small">Languages</div><div id="totalLanguages" class="h4 mb-0">0</div></div></div></div>
        <div class="col-6 col-md-2"><div class="card"><div class="card-body"><div class="text-secondary small">Files</div><div id="totalFiles" class="h4 mb-0">0</div></div></div></div>
        <div class="col-6 col-md-3"><div class="card"><div class="card-body"><div class="text-secondary small">Est. Person-Years</div><div id="personYears" class="h4 mb-0">0</div></div></div></div>
        <div class="col-12 col-md-3"><div class="card"><div class="card-body"><div class="text-secondary small">Est. Cost (USD)</div><div id="estCost" class="h4 mb-0">$0</div></div></div></div>
      </div>

      <div class="card mb-3">
        <div class="card-header d-flex justify-content-between align-items-center">
          <strong>Language Breakdown</strong>
          <span id="analyzedSource" class="badge text-bg-secondary">—</span>
        </div>
        <div class="table-responsive">
          <table class="table table-striped table-hover table-fixed mb-0">
            <thead>
              <tr><th>Language</th><th class="text-end">Lines</th><th class="text-end">%</th><th class="text-end">Files</th></tr>
            </thead>
            <tbody id="languageTableBody"></tbody>
          </table>
        </div>
      </div>

      <div class="card mb-3">
        <div class="card-header"><strong>Cost Model (Basic COCOMO)</strong></div>
        <div class="card-body">
          <div class="row g-3">
            <div class="col-sm-6 col-lg-3"><label class="form-label" for="salaryInput">Annual Salary (USD)</label><input id="salaryInput" class="form-control" type="number" value="56286"></div>
            <div class="col-sm-6 col-lg-3"><label class="form-label" for="overheadInput">Overhead Multiplier</label><input id="overheadInput" class="form-control" type="number" step="0.1" value="2.4"></div>
            <div class="col-sm-6 col-lg-2"><label class="form-label" for="aInput">Effort A</label><input id="aInput" class="form-control" type="number" step="0.01" value="2.4"></div>
            <div class="col-sm-6 col-lg-2"><label class="form-label" for="bInput">Effort B</label><input id="bInput" class="form-control" type="number" step="0.01" value="1.05"></div>
            <div class="col-sm-6 col-lg-1"><label class="form-label" for="cInput">Sched C</label><input id="cInput" class="form-control" type="number" step="0.01" value="2.5"></div>
            <div class="col-sm-6 col-lg-1"><label class="form-label" for="dInput">Sched D</label><input id="dInput" class="form-control" type="number" step="0.01" value="0.38"></div>
          </div>
          <button id="recalcBtn" class="btn btn-outline-secondary btn-sm mt-3">Recalculate</button>
        </div>
      </div>

      <div class="alert alert-warning mb-0">
        <strong>About estimates:</strong> These are rough Basic COCOMO estimates (Barry Boehm), intended for directional planning only. They are not commitments or forecasts.
      </div>
    </section>
  </main>

  <script>
    const SLOC_ASSET_BASE = './lib';
    const COUNTER_MAP = {
      py: { counter: 'python_count', type: 'perl', lang: 'Python' },
      rb: { counter: 'ruby_count', type: 'perl', lang: 'Ruby' },
      pl: { counter: 'perl_count', type: 'perl', lang: 'Perl' },
      pm: { counter: 'perl_count', type: 'perl', lang: 'Perl' },
      sh: { counter: 'sh_count', type: 'wasm', lang: 'Shell' },
      bash: { counter: 'sh_count', type: 'wasm', lang: 'Shell' },
      zsh: { counter: 'sh_count', type: 'wasm', lang: 'Shell' },
      js: { counter: 'javascript_count', type: 'wasm', lang: 'JavaScript' },
      mjs: { counter: 'javascript_count', type: 'wasm', lang: 'JavaScript' },
      cjs: { counter: 'javascript_count', type: 'wasm', lang: 'JavaScript' },
      ts: { counter: 'javascript_count', type: 'wasm', lang: 'TypeScript' },
      jsx: { counter: 'javascript_count', type: 'wasm', lang: 'JavaScript' },
      tsx: { counter: 'javascript_count', type: 'wasm', lang: 'TypeScript' },
      java: { counter: 'generic_count', type: 'wasm', lang: 'Java' },
      c: { counter: 'generic_count', type: 'wasm', lang: 'C' },
      h: { counter: 'generic_count', type: 'wasm', lang: 'C/C++' },
      cpp: { counter: 'generic_count', type: 'wasm', lang: 'C++' },
      cc: { counter: 'generic_count', type: 'wasm', lang: 'C++' },
      cxx: { counter: 'generic_count', type: 'wasm', lang: 'C++' },
      hpp: { counter: 'generic_count', type: 'wasm', lang: 'C++' },
      go: { counter: 'go_count', type: 'perl', lang: 'Go' },
      rs: { counter: 'rust_count', type: 'perl', lang: 'Rust' },
      php: { counter: 'php_count', type: 'wasm', lang: 'PHP' },
      phtml: { counter: 'php_count', type: 'wasm', lang: 'PHP' },
      sql: { counter: 'sql_count', type: 'perl', lang: 'SQL' },
      swift: { counter: 'swift_count', type: 'perl', lang: 'Swift' },
      kt: { counter: 'kotlin_count', type: 'perl', lang: 'Kotlin' },
      kts: { counter: 'kotlin_count', type: 'perl', lang: 'Kotlin' },
      scala: { counter: 'scala_count', type: 'perl', lang: 'Scala' },
      dart: { counter: 'dart_count', type: 'perl', lang: 'Dart' },
      groovy: { counter: 'groovy_count', type: 'perl', lang: 'Groovy' },
      ex: { counter: 'elixir_count', type: 'perl', lang: 'Elixir' },
      exs: { counter: 'elixir_count', type: 'perl', lang: 'Elixir' },
      jl: { counter: 'julia_count', type: 'perl', lang: 'Julia' },
      fs: { counter: 'fsharp_count', type: 'perl', lang: 'F#' },
      fsx: { counter: 'fsharp_count', type: 'perl', lang: 'F#' },
      cs: { counter: 'generic_count', type: 'wasm', lang: 'C#' },
      html: { counter: 'generic_count', type: 'wasm', lang: 'HTML' },
      htm: { counter: 'generic_count', type: 'wasm', lang: 'HTML' },
      css: { counter: 'generic_count', type: 'wasm', lang: 'CSS' },
      xml: { counter: 'generic_count', type: 'wasm', lang: 'XML' },
      lua: { counter: 'generic_count', type: 'wasm', lang: 'Lua' },
      vim: { counter: 'generic_count', type: 'wasm', lang: 'Vim script' },
      y: { counter: 'lexcount1', type: 'wasm', lang: 'Yacc' },
      yacc: { counter: 'lexcount1', type: 'wasm', lang: 'Yacc' },
      l: { counter: 'lexcount1', type: 'wasm', lang: 'Lex' },
      lex: { counter: 'lexcount1', type: 'wasm', lang: 'Lex' },
      ml: { counter: 'ml_count', type: 'wasm', lang: 'OCaml' },
      mli: { counter: 'ml_count', type: 'wasm', lang: 'OCaml' },
      mll: { counter: 'ml_count', type: 'wasm', lang: 'OCaml' },
      mly: { counter: 'ml_count', type: 'wasm', lang: 'OCaml' },
      pig: { counter: 'pig_count', type: 'wasm', lang: 'Pig' }
    };

    const WASM_MODULE_CONFIG = {
      generic_count: { script: 'c_count.js', factory: 'createCCountModule' },
      php_count: { script: 'php_count.js', factory: 'createPhpCountModule' },
      lexcount1: { script: 'lexcount1.js', factory: 'createLexcount1Module' },
      ml_count: { script: 'ml_count.js', factory: 'createMlCountModule' },
      pig_count: { script: 'pig_count.js', factory: 'createPigCountModule' }
    };

    const statusEl = document.getElementById('status');
    const resultsEl = document.getElementById('results');
    const languageBody = document.getElementById('languageTableBody');
    const analyzePasteBtn = document.getElementById('analyzePasteBtn');
    const analyzeGithubBtn = document.getElementById('analyzeGithubBtn');
    const analyzeZipBtn = document.getElementById('analyzeZipBtn');
    const loadedCountersEl = document.getElementById('loadedCounters');

    let lastSummary = null;
    let currentFiles = [];
    let perlReady = false;
    let slocScripts = {};
    let wasmModules = {};

    analyzePasteBtn.disabled = true;
    analyzeGithubBtn.disabled = true;
    analyzeZipBtn.disabled = true;

    function setStatus(message, type = 'secondary') {
      statusEl.className = `alert alert-${type}`;
      statusEl.textContent = message;
    }

    function setTab(tabId) {
      const mapping = [
        { btn: 'paste-tab', pane: 'paste-pane' },
        { btn: 'github-tab', pane: 'github-pane' },
        { btn: 'zip-tab', pane: 'zip-pane' }
      ];
      for (const { btn, pane } of mapping) {
        const isActive = btn === tabId;
        document.getElementById(btn).classList.toggle('active', isActive);
        const paneEl = document.getElementById(pane);
        paneEl.classList.toggle('show', isActive);
        paneEl.classList.toggle('active', isActive);
      }
    }

    document.getElementById('paste-tab').addEventListener('click', () => setTab('paste-tab'));
    document.getElementById('github-tab').addEventListener('click', () => setTab('github-tab'));
    document.getElementById('zip-tab').addEventListener('click', () => setTab('zip-tab'));

    function parseRepoInput(input) {
      const trimmed = (input || '').trim();
      if (!trimmed) return null;
      const urlMatch = trimmed.match(/^https?:\/\/github\.com\/([^\/]+)\/([^\/\s#?]+)/i);
      if (urlMatch) return { owner: urlMatch[1], repo: urlMatch[2].replace(/\.git$/i, '') };
      const shortMatch = trimmed.match(/^([^\/\s]+)\/([^\/\s]+)$/);
      if (shortMatch) return { owner: shortMatch[1], repo: shortMatch[2].replace(/\.git$/i, '') };
      return null;
    }

    function extensionFor(filePath) {
      const lower = (filePath || '').toLowerCase();
      if (!lower) return null;
      if (lower.endsWith('/dockerfile') || lower === 'dockerfile') return 'sh';
      const idx = lower.lastIndexOf('.');
      if (idx === -1) return null;
      return lower.slice(idx + 1);
    }

    function isSupportedSourceFile(filePath) {
      const ext = extensionFor(filePath);
      return !!(ext && COUNTER_MAP[ext]);
    }

    function loadScript(url) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = url;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    async function loadWebPerl() {
      if (window.Perl) return;
      await loadScript('./lib/webperl/webperl.js');
    }

    async function loadJsZip() {
      if (window.JSZip) return window.JSZip;
      await loadScript('./lib/vendor/jszip.min.js');
      return window.JSZip;
    }

    function parseCounterOutput(output) {
      const lines = (output || '').split('\n');
      let groupLines = 0;
      let groupFiles = 0;
      for (const line of lines) {
        if (!line.trim() || line.startsWith('Total:')) continue;
        const match = line.match(/^(\d+)\s+/);
        if (match) {
          groupLines += parseInt(match[1], 10);
          groupFiles += 1;
        }
      }
      return { groupLines, groupFiles };
    }

    async function initializeWebAssemblyEngine() {
      try {
        setStatus('Loading WebAssembly runtime...', 'info');
        if (window.location.protocol === 'file:') {
          if (loadedCountersEl) {
            loadedCountersEl.textContent = 'Loaded counters: unavailable in file:// mode';
          }
          setStatus('This tool cannot run via file:// due to browser security limits for WebAssembly/data fetches. Start a local server from repo root, e.g. `python3 -m http.server 4000`, then open http://localhost:4000/tools/sloccount-web-analyzer.html', 'warning');
          return;
        }

        await loadJsZip();
        await loadWebPerl();

        while (!(window.Perl && Perl.state === 'Running')) {
          await new Promise((resolve) => setTimeout(resolve, 100));
        }

        setStatus('Loading SLOCCount scripts...', 'info');
        const zipRes = await fetch(`${SLOC_ASSET_BASE}/sloccount-perl.zip`);
        if (!zipRes.ok) throw new Error('Unable to fetch sloccount-perl.zip');
        const zipBlob = await zipRes.blob();
        const zip = await JSZip.loadAsync(zipBlob);

        const scriptsToLoad = [
          'python_count', 'perl_count', 'ruby_count', 'generic_count',
          'javascript_count', 'sh_count', 'sql_count', 'lisp_count',
          'asm_count', 'ada_count', 'awk_count', 'cobol_count', 'fortran_count',
          'f90_count', 'haskell_count', 'makefile_count', 'modula3_count',
          'objc_count', 'sed_count', 'tcl_count', 'vbasic_count', 'exp_count',
          'csh_count', 'batch_count', 'vbscript_count', 'autohotkey_count',
          'autoit_count', 'innosetup_count', 'lex_count'
        ];

        for (const scriptName of scriptsToLoad) {
          if (zip.files[scriptName]) {
            slocScripts[scriptName] = await zip.files[scriptName].async('text');
          }
        }

        const modernScripts = [
          'kotlin_count', 'swift_count', 'dart_count', 'scala_count',
          'groovy_count', 'elixir_count', 'julia_count', 'fsharp_count',
          'rust_count', 'go_count'
        ];

        for (const scriptName of modernScripts) {
          try {
            const response = await fetch(`${SLOC_ASSET_BASE}/sloc/${scriptName}`);
            if (response.ok) slocScripts[scriptName] = await response.text();
          } catch {
            // Skip optional scripts that fail to load
          }
        }

        window.counterScripts = slocScripts;
        window.wasmOutput = [];

        const requiredWasmCounters = [...new Set(
          Object.values(COUNTER_MAP)
            .filter((entry) => entry.type === 'wasm')
            .map((entry) => entry.counter)
        )];

        setStatus('Loading WebAssembly counters...', 'info');
        for (const counterName of requiredWasmCounters) {
          const config = WASM_MODULE_CONFIG[counterName];
          if (!config) continue;
          await loadScript(`${SLOC_ASSET_BASE}/wasm/${config.script}`);
          const factory = window[config.factory];
          if (typeof factory !== 'function') {
            throw new Error(`Missing WASM factory: ${config.factory}`);
          }
          wasmModules[counterName] = await factory({
            print: (text) => { window.wasmOutput.push(text); },
            printErr: () => {},
            noInitialRun: true,
            locateFile: (path) => `${SLOC_ASSET_BASE}/wasm/${path}`
          });
        }

        const loadedCounters = Object.keys(wasmModules).sort();
        if (loadedCountersEl) {
          loadedCountersEl.textContent = `Loaded counters: ${loadedCounters.join(', ')}`;
        }
        const counterSummary = loadedCounters.length ? loadedCounters.join(', ') : 'none';

        perlReady = true;
        analyzePasteBtn.disabled = false;
        analyzeGithubBtn.disabled = false;
        analyzeZipBtn.disabled = false;
        setStatus(`WebAssembly SLOCCount ready. Loaded counters: ${counterSummary}`, 'success');
      } catch (error) {
        if (loadedCountersEl) {
          loadedCountersEl.textContent = 'Loaded counters: failed to initialize';
        }
        setStatus(`Failed to initialize WebAssembly engine: ${error.message}. Loaded counters: failed`, 'danger');
      }
    }

    async function runSloccount(files) {
      if (!perlReady) throw new Error('WASM engine is not ready yet.');

      const filesByCounter = {};
      for (const file of files) {
        if (!file || typeof file.content !== 'string' || file.content.includes('\u0000')) continue;
        const ext = extensionFor(file.filename || file.path);
        const counterInfo = ext ? COUNTER_MAP[ext] : null;
        if (!counterInfo) continue;

        const key = `${counterInfo.type}:${counterInfo.counter}:${counterInfo.lang}`;
        if (!filesByCounter[key]) {
          filesByCounter[key] = {
            type: counterInfo.type,
            counter: counterInfo.counter,
            lang: counterInfo.lang,
            files: []
          };
        }
        filesByCounter[key].files.push({
          filename: file.filename || file.path,
          content: file.content
        });
      }

      const langStats = {};
      let totalLines = 0;

      for (const key of Object.keys(filesByCounter)) {
        const group = filesByCounter[key];
        let parsed = { groupLines: 0, groupFiles: 0 };

        if (group.type === 'perl') {
          const script = window.counterScripts[group.counter];
          if (!script) continue;

          const filePaths = [];
          for (let i = 0; i < group.files.length; i += 1) {
            const file = group.files[i];
            const sanitized = file.filename.replace(/[^a-zA-Z0-9._\/-]/g, '_').split('/').pop();
            const path = `/tmp/${Date.now()}_${i}_${sanitized}`;
            window._tempFileContent = file.content;
            Perl.eval(`
              use WebPerl qw/js/;
              my $path = '${path}';
              my $content = js('window')->{_tempFileContent};
              open(my $fh, '>', $path) or die "Cannot write $path: $!";
              print $fh $content;
              close($fh);
            `);
            filePaths.push(path);
          }
          window._tempFileContent = null;

          window.perlCounterOutput = '';
          Perl.eval(`
            use warnings;
            use WebPerl qw/js/;
            my $script = js('window')->{counterScripts}{'${group.counter}'};
            @ARGV = (${filePaths.map((p) => `'${p}'`).join(', ')});
            my $output = '';
            open(my $stdout_fh, '>', \\\$output) or die "Cannot redirect: $!";
            select $stdout_fh;
            eval $script;
            if ($@) { $output .= "ERROR: $@"; }
            select STDOUT;
            close($stdout_fh);
            js('window')->{perlCounterOutput} = $output;
          `);

          parsed = parseCounterOutput(window.perlCounterOutput);
        }

        if (group.type === 'wasm') {
          const module = wasmModules[group.counter] || wasmModules.generic_count;
          if (!module) continue;
          const filePaths = [];

          for (let i = 0; i < group.files.length; i += 1) {
            const file = group.files[i];
            const sanitized = file.filename.replace(/[^a-zA-Z0-9._\/-]/g, '_').split('/').pop();
            const path = `/tmp/${Date.now()}_${i}_${sanitized}`;
            module.FS.writeFile(path, file.content);
            filePaths.push(path);
          }

          window.wasmOutput = [];
          module.callMain(filePaths);
          parsed = parseCounterOutput(window.wasmOutput.join('\n'));
        }

        if (!langStats[group.lang]) {
          langStats[group.lang] = { language: group.lang, lines: 0, files: 0 };
        }
        langStats[group.lang].lines += parsed.groupLines;
        langStats[group.lang].files += parsed.groupFiles;
        totalLines += parsed.groupLines;
      }

      const languages = Object.values(langStats).sort((a, b) => b.lines - a.lines);
      const totalFiles = languages.reduce((acc, row) => acc + row.files, 0);

      return {
        totalLines,
        totalFiles,
        totalLanguages: languages.length,
        languages
      };
    }

    function computeCocomo(totalLines) {
      const kloc = totalLines / 1000;
      const salary = Number(document.getElementById('salaryInput').value || 56286);
      const overhead = Number(document.getElementById('overheadInput').value || 2.4);
      const a = Number(document.getElementById('aInput').value || 2.4);
      const b = Number(document.getElementById('bInput').value || 1.05);
      const c = Number(document.getElementById('cInput').value || 2.5);
      const d = Number(document.getElementById('dInput').value || 0.38);

      const effortPM = kloc > 0 ? a * Math.pow(kloc, b) : 0;
      const scheduleMonths = effortPM > 0 ? c * Math.pow(effortPM, d) : 0;
      const personYears = effortPM / 12;
      const annualLoaded = salary * overhead;
      const cost = personYears * annualLoaded;

      return { effortPM, scheduleMonths, personYears, cost };
    }

    function renderResults(summary, sourceLabel) {
      lastSummary = summary;
      const cocomo = computeCocomo(summary.totalLines);

      document.getElementById('totalLines').textContent = summary.totalLines.toLocaleString();
      document.getElementById('totalLanguages').textContent = summary.totalLanguages.toLocaleString();
      document.getElementById('totalFiles').textContent = summary.totalFiles.toLocaleString();
      document.getElementById('personYears').textContent = cocomo.personYears.toFixed(2);
      document.getElementById('estCost').textContent = `$${Math.round(cocomo.cost).toLocaleString()}`;
      document.getElementById('analyzedSource').textContent = sourceLabel;

      languageBody.innerHTML = '';
      for (const row of summary.languages) {
        const percent = summary.totalLines ? ((row.lines / summary.totalLines) * 100) : 0;
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${row.language}</td><td class="text-end">${row.lines.toLocaleString()}</td><td class="text-end">${percent.toFixed(1)}%</td><td class="text-end">${row.files.toLocaleString()}</td>`;
        languageBody.appendChild(tr);
      }

      resultsEl.classList.remove('d-none');
    }

    async function analyzePaste() {
      const filename = document.getElementById('pasteFilename').value.trim();
      const code = document.getElementById('pasteCode').value;
      if (!filename) { setStatus('Filename is required for paste mode.', 'danger'); return; }
      if (!code.trim()) { setStatus('Code is required for paste mode.', 'danger'); return; }
      if (!isSupportedSourceFile(filename)) {
        setStatus('Unsupported filename extension for SLOCCount analysis.', 'warning');
        return;
      }

      setStatus('Analyzing pasted code with WebAssembly SLOCCount...', 'info');
      const summary = await runSloccount([{ filename, content: code }]);
      if (summary.totalFiles === 0) {
        setStatus('No recognized code files from pasted input.', 'warning');
        return;
      }
      currentFiles = [{ filename, content: code }];
      renderResults(summary, 'Paste Code');
      setStatus('Analysis complete.', 'success');
    }

    async function analyzeGithub() {
      const parsed = parseRepoInput(document.getElementById('githubRepo').value);
      const refInput = document.getElementById('githubRef').value.trim();
      if (!parsed) { setStatus('Enter a valid GitHub repository: owner/repo or full URL.', 'danger'); return; }

      const { owner, repo } = parsed;
      setStatus(`Fetching repository metadata for ${owner}/${repo}...`, 'info');

      const repoRes = await fetch(`https://api.github.com/repos/${owner}/${repo}`);
      if (repoRes.status === 404) { setStatus('Repository not found.', 'danger'); return; }
      if (repoRes.status === 403) { setStatus('GitHub API rate limited. Retry later or use ZIP mode.', 'warning'); return; }
      if (!repoRes.ok) { setStatus(`GitHub error (${repoRes.status}).`, 'danger'); return; }

      const repoJson = await repoRes.json();
      const ref = refInput || repoJson.default_branch;
      setStatus(`Fetching file tree for ref '${ref}'...`, 'info');

      const treeRes = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees/${encodeURIComponent(ref)}?recursive=1`);
      if (treeRes.status === 404) { setStatus('Branch/ref not found.', 'danger'); return; }
      if (!treeRes.ok) { setStatus(`Unable to read repository tree (${treeRes.status}).`, 'danger'); return; }

      const treeJson = await treeRes.json();
      if (treeJson.truncated) {
        setStatus('Repository tree is too large (truncated). Please use ZIP mode.', 'warning');
        return;
      }

      const paths = (treeJson.tree || [])
        .filter((n) => n.type === 'blob')
        .map((n) => n.path)
        .filter((p) => isSupportedSourceFile(p));

      if (paths.length === 0) { setStatus('No recognized code files found in repository.', 'warning'); return; }

      const files = [];
      const batchSize = 8;
      for (let i = 0; i < paths.length; i += batchSize) {
        const batch = paths.slice(i, i + batchSize);
        setStatus(`Downloading files ${i + 1}-${Math.min(i + batch.length, paths.length)} of ${paths.length}...`, 'info');
        const chunks = await Promise.all(batch.map(async (path) => {
          const rawUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${ref}/${path}`;
          try {
            const r = await fetch(rawUrl);
            if (!r.ok) return null;
            const content = await r.text();
            return { filename: path, content };
          } catch {
            return null;
          }
        }));
        for (const f of chunks) if (f) files.push(f);
      }

      if (files.length === 0) { setStatus('Unable to download analyzable files. Try ZIP mode.', 'danger'); return; }

      setStatus(`Running WebAssembly SLOCCount on ${files.length} files...`, 'info');
      const summary = await runSloccount(files);
      currentFiles = files;
      renderResults(summary, `GitHub: ${owner}/${repo}@${ref}`);
      setStatus(`Analysis complete. Processed ${summary.totalFiles} files.`, 'success');
    }

    async function analyzeZip() {
      const input = document.getElementById('zipFile');
      const file = input.files?.[0];
      if (!file) { setStatus('Choose a .zip file first.', 'danger'); return; }
      if (!file.name.toLowerCase().endsWith('.zip')) { setStatus('Only .zip files are supported.', 'danger'); return; }

      setStatus('Loading ZIP parser...', 'info');
      let JSZip;
      try {
        JSZip = await loadJsZip();
      } catch {
        setStatus('Unable to load ZIP parser. Check connection and retry.', 'danger');
        return;
      }

      setStatus('Reading ZIP archive...', 'info');
      const zip = await JSZip.loadAsync(file);
      const entries = Object.values(zip.files).filter((z) => !z.dir && isSupportedSourceFile(z.name));
      if (entries.length === 0) { setStatus('No recognized code files found in ZIP.', 'warning'); return; }

      const files = [];
      let processed = 0;
      for (const entry of entries) {
        processed += 1;
        setStatus(`Extracting ${processed}/${entries.length}: ${entry.name}`, 'info');
        try {
          const content = await entry.async('string');
          files.push({ filename: entry.name, content });
        } catch {
          // Skip unreadable files
        }
      }

      if (!files.length) { setStatus('ZIP parsed, but no readable source files were extracted.', 'danger'); return; }
      setStatus(`Running WebAssembly SLOCCount on ${files.length} files...`, 'info');
      const summary = await runSloccount(files);
      currentFiles = files;
      renderResults(summary, `ZIP: ${file.name}`);
      setStatus(`Analysis complete. Processed ${summary.totalFiles} files from ZIP.`, 'success');
    }

    document.getElementById('analyzePasteBtn').addEventListener('click', () => analyzePaste().catch((e) => setStatus(`Paste analysis failed: ${e.message}`, 'danger')));
    document.getElementById('analyzeGithubBtn').addEventListener('click', () => analyzeGithub().catch((e) => setStatus(`GitHub analysis failed: ${e.message}`, 'danger')));
    document.getElementById('analyzeZipBtn').addEventListener('click', () => analyzeZip().catch((e) => setStatus(`ZIP analysis failed: ${e.message}`, 'danger')));

    document.getElementById('recalcBtn').addEventListener('click', () => {
      if (!lastSummary) {
        setStatus('Run an analysis first, then recalculate.', 'warning');
        return;
      }
      renderResults(lastSummary, document.getElementById('analyzedSource').textContent || 'Analysis');
      setStatus('Cost model recalculated.', 'success');
    });

    document.getElementById('githubRepo').addEventListener('keypress', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        if (!analyzeGithubBtn.disabled) analyzeGithub().catch((e) => setStatus(`GitHub analysis failed: ${e.message}`, 'danger'));
      }
    });

    initializeWebAssemblyEngine();
  </script>
  <script type="text/perl">
    1;
  </script>
</body>
</html>
