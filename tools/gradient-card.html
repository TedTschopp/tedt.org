<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gradient image generator</title>
<link rel="icon" href="../favicon.ico" sizes="any">
<script>
  (function loadStylesheets() {
    const isFileProtocol = window.location.protocol === 'file:';
    document.documentElement.setAttribute('data-file-protocol', String(isFileProtocol));

    const stylesheets = isFileProtocol
      ? ['https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css']
      : ['../css/bootstrap-build.css', '../css/consolidated-fonts.css'];

    for (const href of stylesheets) {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = href;
      document.head.appendChild(link);
    }
  })();
</script>
<style>
body { background: var(--bs-body-bg); }
.app-wrap { max-width: 1200px; }
.muted-note { color: var(--bs-secondary-color); font-size: 0.9rem; }
.preview-wrap { position: sticky; top: 1rem; }
.canvas-shell { border: 1px solid var(--bs-border-color); border-radius: 0.5rem; padding: 0.75rem; background: rgba(var(--bs-body-color-rgb), 0.02); }

canvas {
  width: 100%;
  height: auto;
  display: block;
  border-radius: 0.35rem;
}

.controls { max-height: calc(100vh - 2rem); overflow-y: auto; }
.section { margin-bottom: 0.75rem; }
.field { margin-bottom: 0.8rem; }
.field:last-child { margin-bottom: 0; }

.field-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.35rem;
}

.field-row label {
  font-size: 0.86rem;
  color: var(--bs-secondary-color);
}

.field-row .value {
  font-size: 0.8rem;
  color: var(--bs-secondary-color);
  font-variant-numeric: tabular-nums;
}

.color-pair {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}

.color-pair label {
  font-size: 0.8rem;
  color: var(--bs-secondary-color);
  width: 1rem;
}

.json-actions {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
}

.toast {
  position: fixed;
  bottom: 1rem;
  left: 50%;
  transform: translateX(-50%) translateY(120%);
  background: var(--bs-primary);
  color: var(--bs-light);
  padding: 0.5rem 0.85rem;
  border-radius: 0.45rem;
  font-size: 0.82rem;
  font-weight: 600;
  pointer-events: none;
  opacity: 0;
  transition: transform 0.22s ease, opacity 0.22s ease;
  z-index: 1050;
}

.toast.show {
  transform: translateX(-50%) translateY(0%);
  opacity: 1;
}

.dims {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}

.dims input[type="text"] {
  width: 5.25rem;
  text-align: center;
}

.dims span {
  color: var(--bs-secondary-color);
  font-size: 0.85rem;
}

.checkbox-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.86rem;
  color: var(--bs-secondary-color);
  cursor: pointer;
}

@media (max-width: 991.98px) {
  .controls {
    max-height: none;
  }
  .preview-wrap {
    position: static;
  }
}
</style>
</head>
<body>
<main class="container app-wrap py-4">
  <div class="mb-3">
    <h1 class="h2 mb-1">Gradient image generator</h1>
    <p class="mb-0 muted-note">Build gradient cards with layered patterns and export PNG output directly in your browser.</p>
  </div>

  <div id="status" class="alert alert-secondary" role="status" aria-live="polite">Ready.</div>

  <div class="row g-3 align-items-start">
    <div class="col-lg-8">
      <div class="preview-wrap">
        <div class="card">
          <div class="card-header d-flex justify-content-between align-items-center">
            <strong>Preview</strong>
            <span class="badge text-bg-secondary" id="canvasBadge">1600 × 800</span>
          </div>
          <div class="card-body">
            <div class="canvas-shell">
              <canvas id="canvas"></canvas>
            </div>
            <div class="d-flex gap-2 mt-3">
              <button class="btn btn-primary flex-fill" id="downloadBtn">Download PNG</button>
              <button class="btn btn-outline-secondary flex-fill" id="randomBtn">Randomize</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg-4">
      <div id="controls" class="controls"></div>
    </div>
  </div>
</main>
<div class="toast" id="toast"></div>

<script type="module">
const defaults = {
  width: 1600,
  height: 800,
  gradientType: "linear",
  color1: "#0a2463",
  color2: "#3e92cc",
  color3: "#1b4965",
  useColor3: false,
  color3Stop: 50,
  angle: 135,
  radialX: 50,
  radialY: 50,
  radialRadius: 80,
  pattern: "noise",
  patternOpacity: 12,
  patternScale: 3,
  patternDensity: 50,
  patternColor: "#ffffff",
  patternAngle: 0,
  pattern2: "none",
  pattern2Opacity: 8,
  pattern2Scale: 5,
  pattern2Density: 40,
  pattern2Color: "#ffffff",
  pattern2Angle: 45,
  vignetteStrength: 20,
  vignetteSize: 70,
  noiseAmount: 5,
  blendMode: "normal",
  blendMode2: "normal",
};

let S = { ...defaults };
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const statusEl = document.getElementById("status");
const canvasBadgeEl = document.getElementById("canvasBadge");
const LOCAL_SERVER_COMMAND = "python3 -m http.server 4000";

function setStatus(message, type = "secondary", allowHtml = false) {
  statusEl.className = `alert alert-${type}`;
  if (allowHtml) {
    statusEl.innerHTML = message;
  } else {
    statusEl.textContent = message;
  }
}

function showFileProtocolWarning() {
  setStatus(
    'Opened with file://. If styles look off, run a local server for full parity.' +
    '<div class="mt-2 d-flex flex-wrap gap-2 align-items-center">' +
    '<button id="copyLocalServeCmd" type="button" class="btn btn-sm btn-outline-dark">Copy local server command</button>' +
    '<span class="small">Then open <code>http://localhost:4000/tools/gradient-card.html</code></span>' +
    '</div>',
    'warning',
    true
  );

  const copyBtn = document.getElementById('copyLocalServeCmd');
  if (!copyBtn) return;

  copyBtn.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(LOCAL_SERVER_COMMAND);
      const original = copyBtn.textContent;
      copyBtn.textContent = 'Copied';
      setTimeout(() => {
        copyBtn.textContent = original;
      }, 1200);
    } catch {
      setStatus(`Run this in repo root: ${LOCAL_SERVER_COMMAND}`, 'warning');
    }
  });
}

function showToast(msg) {
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(() => t.classList.remove("show"), 1800);
}

function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function drawPattern(context, w, h, cfg) {
  const { type, opacity, scale, density, color, angle, blendMode } = cfg;
  if (type === "none") return;

  context.save();
  context.globalAlpha = opacity / 100;
  context.globalCompositeOperation = blendMode;

  const cx = w / 2, cy = h / 2;

  if (angle !== 0) {
    context.translate(cx, cy);
    context.rotate((angle * Math.PI) / 180);
    context.translate(-cx, -cy);
  }

  const s = Math.max(1, scale);
  const d = Math.max(5, 105 - density);

  switch (type) {
    case "dots": {
      const spacing = d * s * 0.4;
      context.fillStyle = color;
      const pad = spacing * 2;
      for (let x = -pad; x < w + pad; x += spacing) {
        for (let y = -pad; y < h + pad; y += spacing) {
          context.beginPath();
          context.arc(x, y, s * 1.2, 0, Math.PI * 2);
          context.fill();
        }
      }
      break;
    }
    case "lines": {
      const spacing = d * s * 0.5;
      context.strokeStyle = color;
      context.lineWidth = s * 0.5;
      const pad = Math.max(w, h);
      for (let i = -pad; i < pad * 2; i += spacing) {
        context.beginPath();
        context.moveTo(i, -pad);
        context.lineTo(i, pad * 2);
        context.stroke();
      }
      break;
    }
    case "crosshatch": {
      const spacing = d * s * 0.4;
      context.strokeStyle = color;
      context.lineWidth = s * 0.4;
      const pad = Math.max(w, h);
      for (let i = -pad; i < pad * 2; i += spacing) {
        context.beginPath();
        context.moveTo(i, -pad);
        context.lineTo(i, pad * 2);
        context.stroke();
        context.beginPath();
        context.moveTo(-pad, i);
        context.lineTo(pad * 2, i);
        context.stroke();
      }
      break;
    }
    case "grid": {
      const spacing = d * s * 0.6;
      context.strokeStyle = color;
      context.lineWidth = s * 0.3;
      const pad = Math.max(w, h);
      for (let i = -pad; i < pad * 2; i += spacing) {
        context.beginPath();
        context.moveTo(i, -pad);
        context.lineTo(i, pad * 2);
        context.stroke();
        context.beginPath();
        context.moveTo(-pad, i);
        context.lineTo(pad * 2, i);
        context.stroke();
      }
      break;
    }
    case "diamonds": {
      const spacing = d * s * 0.5;
      context.strokeStyle = color;
      context.lineWidth = s * 0.4;
      const pad = Math.max(w, h);
      for (let i = -pad; i < pad * 2; i += spacing) {
        context.beginPath();
        context.moveTo(i, -pad);
        context.lineTo(i + pad * 2, pad);
        context.stroke();
        context.beginPath();
        context.moveTo(i, -pad);
        context.lineTo(i - pad * 2, pad);
        context.stroke();
      }
      break;
    }
    case "waves": {
      const spacing = d * s * 0.4;
      const amp = s * 6;
      const freq = 0.02 / s;
      context.strokeStyle = color;
      context.lineWidth = s * 0.5;
      const pad = spacing * 2;
      for (let row = -pad; row < h + pad; row += spacing) {
        context.beginPath();
        for (let x = -pad; x <= w + pad; x += 2) {
          const y = row + Math.sin(x * freq * density * 0.3) * amp;
          x === -pad ? context.moveTo(x, y) : context.lineTo(x, y);
        }
        context.stroke();
      }
      break;
    }
    case "circles": {
      const spacing = d * s * 0.8;
      context.strokeStyle = color;
      context.lineWidth = s * 0.3;
      const maxR = Math.max(w, h);
      for (let r = spacing; r < maxR; r += spacing) {
        context.beginPath();
        context.arc(cx, cy, r, 0, Math.PI * 2);
        context.stroke();
      }
      break;
    }
    case "triangles": {
      const spacing = d * s * 0.5;
      context.strokeStyle = color;
      context.lineWidth = s * 0.35;
      const pad = spacing * 2;
      let rowIdx = 0;
      for (let y = -pad; y < h + pad; y += spacing * 0.866) {
        const offset = (rowIdx % 2) * (spacing / 2);
        for (let x = -pad + offset; x < w + pad; x += spacing) {
          context.beginPath();
          context.moveTo(x, y);
          context.lineTo(x + spacing / 2, y + spacing * 0.866);
          context.lineTo(x - spacing / 2, y + spacing * 0.866);
          context.closePath();
          context.stroke();
        }
        rowIdx++;
      }
      break;
    }
    case "noise": {
      const rand = mulberry32(42);
      const blockSize = Math.max(1, Math.round(s * 1.5));
      const prob = density / 100;
      for (let x = 0; x < w; x += blockSize) {
        for (let y = 0; y < h; y += blockSize) {
          if (rand() < prob) {
            const a = rand() * 0.6;
            context.fillStyle = color;
            context.globalAlpha = (opacity / 100) * a;
            context.fillRect(x, y, blockSize, blockSize);
          }
        }
      }
      context.globalAlpha = opacity / 100;
      break;
    }
    case "stipple": {
      const rand2 = mulberry32(77);
      const count = density * w * h * 0.00003 * s;
      context.fillStyle = color;
      for (let i = 0; i < count; i++) {
        const x = rand2() * w;
        const y = rand2() * h;
        const r = rand2() * s * 1.5 + 0.5;
        context.beginPath();
        context.arc(x, y, r, 0, Math.PI * 2);
        context.fill();
      }
      break;
    }
    case "hexagons": {
      const size = d * s * 0.3;
      context.strokeStyle = color;
      context.lineWidth = s * 0.3;
      const h2 = size * Math.sqrt(3);
      const pad = size * 3;
      for (let row = -2; row < (h + pad) / (h2); row++) {
        for (let col = -2; col < (w + pad) / (size * 1.5); col++) {
          const cx2 = col * size * 1.5;
          const cy2 = row * h2 + (col % 2 ? h2 / 2 : 0);
          context.beginPath();
          for (let i = 0; i < 6; i++) {
            const a = (Math.PI / 3) * i - Math.PI / 6;
            const hx = cx2 + size * 0.6 * Math.cos(a);
            const hy = cy2 + size * 0.6 * Math.sin(a);
            i === 0 ? context.moveTo(hx, hy) : context.lineTo(hx, hy);
          }
          context.closePath();
          context.stroke();
        }
      }
      break;
    }
  }
  context.restore();
}

function render() {
  const w = S.width;
  const h2 = S.height;
  canvas.width = w;
  canvas.height = h2;
  canvasBadgeEl.textContent = `${w.toLocaleString()} × ${h2.toLocaleString()}`;

  let grad;
  if (S.gradientType === "linear") {
    const a = (S.angle * Math.PI) / 180;
    const len = Math.max(w, h2);
    const dx = Math.cos(a) * len;
    const dy = Math.sin(a) * len;
    grad = ctx.createLinearGradient(w/2 - dx/2, h2/2 - dy/2, w/2 + dx/2, h2/2 + dy/2);
  } else if (S.gradientType === "radial") {
    const rx = (S.radialX / 100) * w;
    const ry = (S.radialY / 100) * h2;
    const rr = (S.radialRadius / 100) * Math.max(w, h2);
    grad = ctx.createRadialGradient(rx, ry, 0, rx, ry, rr);
  } else {
    const a = (S.angle * Math.PI) / 180;
    grad = ctx.createConicGradient(a, w/2, h2/2);
  }

  grad.addColorStop(0, S.color1);
  if (S.useColor3) {
    grad.addColorStop(S.color3Stop / 100, S.color3);
  }
  grad.addColorStop(1, S.color2);

  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, w, h2);

  drawPattern(ctx, w, h2, {
    type: S.pattern,
    opacity: S.patternOpacity,
    scale: S.patternScale,
    density: S.patternDensity,
    color: S.patternColor,
    angle: S.patternAngle,
    blendMode: S.blendMode,
  });

  drawPattern(ctx, w, h2, {
    type: S.pattern2,
    opacity: S.pattern2Opacity,
    scale: S.pattern2Scale,
    density: S.pattern2Density,
    color: S.pattern2Color,
    angle: S.pattern2Angle,
    blendMode: S.blendMode2,
  });

  if (S.noiseAmount > 0) {
    const imageData = ctx.getImageData(0, 0, w, h2);
    const data = imageData.data;
    const rand = mulberry32(123);
    const amt = S.noiseAmount * 2.55;
    for (let i = 0; i < data.length; i += 4) {
      const n = (rand() - 0.5) * amt;
      data[i] += n;
      data[i+1] += n;
      data[i+2] += n;
    }
    ctx.putImageData(imageData, 0, 0);
  }

  if (S.vignetteStrength > 0) {
    const vr = Math.max(w, h2) * (S.vignetteSize / 100);
    const vg = ctx.createRadialGradient(w/2, h2/2, vr * 0.3, w/2, h2/2, vr);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, `rgba(0,0,0,${S.vignetteStrength / 100})`);
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, w, h2);
  }
}

const patternTypes = [
  ["none", "None"], ["noise", "Noise"], ["stipple", "Stipple"],
  ["dots", "Dots"], ["lines", "Lines"], ["crosshatch", "Crosshatch"],
  ["grid", "Grid"], ["diamonds", "Diamonds"], ["waves", "Waves"],
  ["circles", "Concentric circles"], ["triangles", "Triangles"],
  ["hexagons", "Hexagons"],
];

const blendModes = [
  "normal", "multiply", "screen", "overlay", "soft-light",
  "hard-light", "difference", "exclusion", "lighten", "darken",
];

function buildControls() {
  const c = document.getElementById("controls");
  c.innerHTML = "";

  const sections = [
    {
      title: "Canvas",
      fields: [
        { type: "dims", key1: "width", key2: "height" },
      ]
    },
    {
      title: "Gradient",
      fields: [
        { type: "select", key: "gradientType", label: "Type", options: [["linear","Linear"],["radial","Radial"],["conic","Conic"]] },
        { type: "colorpair", label: "Colors" },
        { type: "checkbox", key: "useColor3", label: "Third color stop" },
        ...(S.useColor3 ? [
          { type: "color", key: "color3", label: "Color 3" },
          { type: "range", key: "color3Stop", label: "Stop position", min: 5, max: 95, suffix: "%" },
        ] : []),
        ...(S.gradientType !== "radial" ? [
          { type: "range", key: "angle", label: "Angle", min: 0, max: 360, suffix: "°" },
        ] : []),
        ...(S.gradientType === "radial" ? [
          { type: "range", key: "radialX", label: "Center X", min: 0, max: 100, suffix: "%" },
          { type: "range", key: "radialY", label: "Center Y", min: 0, max: 100, suffix: "%" },
          { type: "range", key: "radialRadius", label: "Radius", min: 10, max: 150, suffix: "%" },
        ] : []),
      ]
    },
    {
      title: "Pattern 1",
      fields: [
        { type: "select", key: "pattern", label: "Type", options: patternTypes },
        ...(S.pattern !== "none" ? [
          { type: "range", key: "patternOpacity", label: "Opacity", min: 1, max: 60, suffix: "%" },
          { type: "range", key: "patternScale", label: "Scale", min: 1, max: 20 },
          { type: "range", key: "patternDensity", label: "Density", min: 5, max: 95 },
          { type: "color", key: "patternColor", label: "Color" },
          { type: "range", key: "patternAngle", label: "Rotation", min: 0, max: 180, suffix: "°" },
          { type: "select", key: "blendMode", label: "Blend mode", options: blendModes.map((b) => [b, b.charAt(0).toUpperCase() + b.slice(1)]) },
        ] : []),
      ]
    },
    {
      title: "Pattern 2",
      fields: [
        { type: "select", key: "pattern2", label: "Type", options: patternTypes },
        ...(S.pattern2 !== "none" ? [
          { type: "range", key: "pattern2Opacity", label: "Opacity", min: 1, max: 60, suffix: "%" },
          { type: "range", key: "pattern2Scale", label: "Scale", min: 1, max: 20 },
          { type: "range", key: "pattern2Density", label: "Density", min: 5, max: 95 },
          { type: "color", key: "pattern2Color", label: "Color" },
          { type: "range", key: "pattern2Angle", label: "Rotation", min: 0, max: 180, suffix: "°" },
          { type: "select", key: "blendMode2", label: "Blend mode", options: blendModes.map((b) => [b, b.charAt(0).toUpperCase() + b.slice(1)]) },
        ] : []),
      ]
    },
    {
      title: "Effects",
      fields: [
        { type: "range", key: "noiseAmount", label: "Film grain", min: 0, max: 40 },
        { type: "range", key: "vignetteStrength", label: "Vignette strength", min: 0, max: 80, suffix: "%" },
        { type: "range", key: "vignetteSize", label: "Vignette size", min: 30, max: 120, suffix: "%" },
      ]
    },
    {
      title: "Presets",
      fields: [
        { type: "json" },
      ]
    },
  ];

  for (const sec of sections) {
    const div = document.createElement("div");
    div.className = "section card";
    div.innerHTML = `<div class="card-header"><strong>${sec.title}</strong></div><div class="card-body"></div>`;
    const body = div.querySelector(".card-body");

    for (const f of sec.fields) {
      const fd = document.createElement("div");
      fd.className = "field";

      if (f.type === "range") {
        const val = S[f.key];
        fd.innerHTML = `
          <div class="field-row">
            <label>${f.label}</label>
            <span class="value">${val}${f.suffix || ""}</span>
          </div>
          <input class="form-range" type="range" min="${f.min}" max="${f.max}" value="${val}" data-key="${f.key}" data-suffix="${f.suffix || ""}">
        `;
        fd.querySelector("input").addEventListener("input", (e) => {
          S[f.key] = Number(e.target.value);
          e.target.previousElementSibling.querySelector(".value").textContent = e.target.value + (f.suffix || "");
          render();
        });
      } else if (f.type === "select") {
        fd.innerHTML = `
          <div class="field-row"><label class="form-label mb-1">${f.label}</label></div>
          <select class="form-select form-select-sm" data-key="${f.key}">
            ${f.options.map(([v, l]) => `<option value="${v}" ${S[f.key] === v ? "selected" : ""}>${l}</option>`).join("")}
          </select>
        `;
        fd.querySelector("select").addEventListener("change", (e) => {
          S[f.key] = e.target.value;
          buildControls();
          render();
        });
      } else if (f.type === "color") {
        fd.innerHTML = `
          <div class="field-row">
            <label class="form-label mb-0">${f.label}</label>
            <input class="form-control form-control-color" type="color" value="${S[f.key]}" data-key="${f.key}">
          </div>
        `;
        fd.querySelector("input").addEventListener("input", (e) => {
          S[f.key] = e.target.value;
          render();
        });
      } else if (f.type === "colorpair") {
        fd.innerHTML = `
          <div class="color-pair">
            <label>A</label><input class="form-control form-control-color" type="color" value="${S.color1}" data-key="color1">
            <label>B</label><input class="form-control form-control-color" type="color" value="${S.color2}" data-key="color2">
            <button class="btn btn-outline-secondary btn-sm" data-action="swap-colors">Swap</button>
          </div>
        `;
        fd.querySelectorAll("input").forEach((inp) => {
          inp.addEventListener("input", (e) => {
            S[e.target.dataset.key] = e.target.value;
            render();
          });
        });
        fd.querySelector('[data-action="swap-colors"]').addEventListener("click", () => {
          [S.color1, S.color2] = [S.color2, S.color1];
          buildControls();
          render();
          setStatus("Swapped gradient colors.", "info");
        });
      } else if (f.type === "checkbox") {
        fd.innerHTML = `
          <label class="checkbox-row">
            <input class="form-check-input m-0" type="checkbox" ${S[f.key] ? "checked" : ""} data-key="${f.key}">
            ${f.label}
          </label>
        `;
        fd.querySelector("input").addEventListener("change", (e) => {
          S[f.key] = e.target.checked;
          buildControls();
          render();
        });
      } else if (f.type === "dims") {
        fd.innerHTML = `
          <div class="dims">
            <input class="form-control form-control-sm" type="text" value="${S.width}" data-key="width" placeholder="W">
            <span>×</span>
            <input class="form-control form-control-sm" type="text" value="${S.height}" data-key="height" placeholder="H">
            <span>px</span>
          </div>
        `;
        fd.querySelectorAll("input").forEach((inp) => {
          inp.addEventListener("change", (e) => {
            const v = parseInt(e.target.value) || (e.target.dataset.key === "width" ? 1600 : 800);
            S[e.target.dataset.key] = Math.max(100, Math.min(4000, v));
            e.target.value = S[e.target.dataset.key];
            render();
          });
        });
      } else if (f.type === "json") {
        fd.className = "field json-section";
        fd.innerHTML = `
          <div class="json-actions">
            <button class="btn btn-outline-secondary btn-sm" id="copyJson">Copy settings</button>
            <button class="btn btn-outline-secondary btn-sm" id="pasteJson">Restore settings</button>
          </div>
          <button class="btn btn-outline-secondary btn-sm" id="resetBtn" style="width:100%;">Reset to defaults</button>
        `;
        fd.querySelector("#copyJson").addEventListener("click", () => {
          navigator.clipboard.writeText(JSON.stringify(S, null, 2)).then(() => {
            showToast("Settings copied to clipboard");
            setStatus("Settings copied to clipboard.", "success");
          });
        });
        fd.querySelector("#pasteJson").addEventListener("click", () => {
          const input = prompt("Paste settings JSON:");
          if (input) {
            try {
              const parsed = JSON.parse(input);
              Object.assign(S, parsed);
              buildControls();
              render();
              showToast("Settings restored");
              setStatus("Settings restored from JSON.", "success");
            } catch {
              showToast("Invalid JSON");
              setStatus("Invalid JSON settings payload.", "warning");
            }
          }
        });
        fd.querySelector("#resetBtn").addEventListener("click", () => {
          Object.assign(S, { ...defaults });
          buildControls();
          render();
          showToast("Reset to defaults");
          setStatus("Controls reset to defaults.", "info");
        });
      }
      body.appendChild(fd);
    }
    c.appendChild(div);
  }
}

function randomize() {
  const randHue = () => 190 + Math.random() * 60;
  const randSL = () => {
    const s = 40 + Math.random() * 50;
    const l = 10 + Math.random() * 40;
    return [s, l];
  };
  const hslToHex = (h, s, l) => {
    const el = document.createElement("canvas").getContext("2d");
    el.fillStyle = `hsl(${h}, ${s}%, ${l}%)`;
    return el.fillStyle;
  };

  const h1 = randHue(), [s1, l1] = randSL();
  const h2 = randHue(), [s2, l2] = randSL();

  S.color1 = hslToHex(h1, s1, l1);
  S.color2 = hslToHex(h2, s2, l2);
  S.gradientType = ["linear", "radial", "conic"][Math.floor(Math.random() * 3)];
  S.angle = Math.floor(Math.random() * 360);
  S.radialX = 30 + Math.random() * 40;
  S.radialY = 30 + Math.random() * 40;
  S.radialRadius = 50 + Math.random() * 60;

  const pats = patternTypes.filter((p) => p[0] !== "none").map((p) => p[0]);
  S.pattern = pats[Math.floor(Math.random() * pats.length)];
  S.patternOpacity = 5 + Math.floor(Math.random() * 25);
  S.patternScale = 1 + Math.floor(Math.random() * 10);
  S.patternDensity = 20 + Math.floor(Math.random() * 60);
  S.patternAngle = Math.floor(Math.random() * 180);
  S.blendMode = blendModes[Math.floor(Math.random() * blendModes.length)];

  S.pattern2 = Math.random() > 0.5 ? pats[Math.floor(Math.random() * pats.length)] : "none";
  if (S.pattern2 !== "none") {
    S.pattern2Opacity = 3 + Math.floor(Math.random() * 15);
    S.pattern2Scale = 1 + Math.floor(Math.random() * 12);
    S.pattern2Density = 20 + Math.floor(Math.random() * 60);
    S.pattern2Angle = Math.floor(Math.random() * 180);
    S.blendMode2 = blendModes[Math.floor(Math.random() * blendModes.length)];
  }

  S.useColor3 = Math.random() > 0.6;
  if (S.useColor3) {
    const h3 = randHue();
    const [s3, l3] = randSL();
    S.color3 = hslToHex(h3, s3, l3);
    S.color3Stop = 30 + Math.floor(Math.random() * 40);
  }

  S.noiseAmount = Math.floor(Math.random() * 15);
  S.vignetteStrength = Math.floor(Math.random() * 40);
  S.vignetteSize = 50 + Math.floor(Math.random() * 50);

  buildControls();
  render();
  setStatus("Randomized gradient settings.", "info");
}

document.getElementById("downloadBtn").addEventListener("click", () => {
  const link = document.createElement("a");
  link.download = `gradient-${S.width}x${S.height}.png`;
  link.href = canvas.toDataURL("image/png");
  link.click();
  showToast("Image downloaded");
  setStatus(`Downloaded PNG (${S.width} × ${S.height}).`, "success");
});

document.getElementById("randomBtn").addEventListener("click", randomize);

buildControls();
render();
if (window.location.protocol === 'file:') {
  showFileProtocolWarning();
} else {
  setStatus("Ready. Adjust settings or randomize to generate a new card.", "secondary");
}
</script>
</body>
</html>
