
{% if page.mastodon-post-id != null or page.mastodon-post-id != empty %}
    <!-- Mastodon Interaction Button Styles -->
    <style>
        /* Mastodon interaction button styling */
        .show-replies-btn, .hide-replies-btn, .reply-btn, .boost-btn, .favorite-btn, .bookmark-btn {
            transition: all 0.2s ease-in-out;
            border-radius: 50%;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .show-replies-btn:hover, .hide-replies-btn:hover, .reply-btn:hover, 
        .boost-btn:hover, .favorite-btn:hover, .bookmark-btn:hover {
            background-color: rgba(0, 123, 255, 0.1);
            transform: scale(1.1);
        }

        .show-replies-btn.active, .hide-replies-btn.active {
            background-color: rgba(23, 162, 184, 0.2);
        }

        .reply-btn.active {
            background-color: rgba(40, 167, 69, 0.2);
        }

        .boost-btn.active {
            background-color: rgba(255, 193, 7, 0.2);
        }

        .favorite-btn.active {
            background-color: rgba(220, 53, 69, 0.2);
        }

        .bookmark-btn.active {
            background-color: rgba(23, 162, 184, 0.2);
        }

        /* Button feedback animations */
        .btn-primary { background-color: #007bff !important; }
        .btn-success { background-color: #28a745 !important; }
        .btn-info { background-color: #17a2b8 !important; }
        .btn-warning { background-color: #ffc107 !important; }
        .btn-danger { background-color: #dc3545 !important; }
        .btn-secondary { background-color: #6c757d !important; }

        /* Accessibility improvements */
        button[data-action]:focus {
            outline: 2px solid #007bff;
            outline-offset: 2px;
        }

        /* Hide/show replies animation */
        .tootReplies, .tootSubReplies {
            transition: opacity 0.3s ease-in-out;
        }

        .tootReplies[style*="display: none"], .tootSubReplies[style*="display: none"] {
            opacity: 0;
        }
    </style>

    <section id="comments" class="article-content">
        <h2 id="Comments-Header">Comments</h2>
        <p>With an account on the Fediverse or Mastodon, you can respond to this <a href="https://{{site.mastodon_comments.host}}/@{{.site.mastodon_comments.username }}/{{page.mastodon-post-id}}">post</a>. Since Mastodon is decentralized, you can use your existing account hosted by another Mastodon server or compatible platform if you don't have an account on this one. Known non-private replies are displayed below.</p>

        <p id="mastodon-comments-list"></p>

        <div id="comments-wrapper">
            <noscript><p>Loading comments relies on JavaScript. Try enabling JavaScript and reloading, or visit <a href="https://{{site.mastodon_comments.host}}/@{{.site.mastodon_comments.username }}/{{page.mastodon-post-id}}">the original post</a> on Mastodon.</p></noscript>
        </div>

        <noscript>You need JavaScript to view the comments.</noscript>
    </section>

    <!-- <script language="JavaScript" src="/js/comments-mastodon-tree.js"></script> -->

    <section id="displayTootThread" class="article-content">
        <div class="row g-0 p-0 m-0 d-flex align-items-start tootThread"  id="displayToot">
            <div class="card p-0 m-0">
                <div class="card-header">
                    <div class="card-body p-0 m-0">
                        <div class="row w-100 p-0 m-0">
                            <div class="col-1 pt-2 d-flex align-items-center justify-content-center avatar" style="max-width: 4.5em;">
                                <a rel="external nofollow" href="" class="avatar-link authorLink">
                                    <img class="m-1 avatarImg avatar" style="height: 2.5em;" src="">
                                </a>
                            </div>
                            <div class="col-6"> 
                                <p class="text-start p-0 m-0 displayName"><a href="" class="displayNameLink authorLink" target="_blank"><span class="displayNameSpan"></span></a></p>
                                <p class="text-start p-0 m-0 "><span class="userNameSpan"></span><span class="instanceNameSpan"></span></p>
                            </div>
                            <div class="col-5 createdAt"> 
                                <p class="card-title p-3 m-0 text-end"><a href="" target="_blank" class="createdAtLink"></a></p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card-body p-0 m-0">
                    <div class="row w-100 p-0 m-0 ">
                        <p class="card-title p-3 m-0 text-start content"></p>
                    </div>
                </div>
                <div class="card-body p-0 m-0">
                    <div class="row w-100 p-0 m-0 attachments">
                    </div>
                </div>
                <footer class="card-footer text-muted" role="contentinfo">
                    <nav class="row w-100" role="navigation" aria-label="Post interactions">
                        <div class="col-2 text-center d-flex align-items-center justify-content-center">
                            <button type="button" 
                                    class="btn btn-link p-0 border-0 show-replies-btn" 
                                    aria-label="Show replies" 
                                    data-action="show-replies"
                                    data-post-id="">
                                <i class="fa-solid fa-comments" aria-hidden="true"></i>
                            </button>
                        </div>
                        <div class="col-2 text-center d-flex align-items-center justify-content-center">
                            <button type="button" 
                                    class="btn btn-link p-0 border-0 reply-btn" 
                                    aria-label="Reply to post" 
                                    data-action="reply"
                                    data-post-url="">
                                <i class="fa-solid fa-reply" aria-hidden="true"></i>
                            </button>
                        </div>
                        <div class="col-2 text-center d-flex align-items-center justify-content-center">
                            <button type="button" 
                                    class="btn btn-link p-0 border-0 boost-btn" 
                                    aria-label="Boost post" 
                                    data-action="boost"
                                    data-post-url="">
                                <i class="fa-solid fa-rocket" aria-hidden="true"></i>
                            </button>
                        </div>
                        <div class="col-2 text-center d-flex align-items-center justify-content-center">
                            <button type="button" 
                                    class="btn btn-link p-0 border-0 favorite-btn" 
                                    aria-label="Favorite post" 
                                    data-action="favorite"
                                    data-post-url="">
                                <i class="fa-regular fa-heart" aria-hidden="true"></i>
                            </button>
                        </div>
                        <div class="col-2 text-center d-flex align-items-center justify-content-center">
                            <button type="button" 
                                    class="btn btn-link p-0 border-0 bookmark-btn" 
                                    aria-label="Bookmark post" 
                                    data-action="bookmark"
                                    data-post-url="">
                                <i class="fa-solid fa-bookmark" aria-hidden="true"></i>
                            </button>
                        </div>
                        <div class="col-2 text-center d-flex align-items-center justify-content-center">
                            <button type="button" 
                                    class="btn btn-link p-0 border-0 hide-replies-btn" 
                                    aria-label="Hide replies" 
                                    data-action="hide-replies"
                                    data-post-id="">
                                <i class="fa-solid fa-eye-slash" aria-hidden="true"></i>
                            </button>
                        </div>
                    </nav>
                </footer>
                <div class="card-body p-0 m-0">
                    <div class="row w-100 p-0 m-0 tootReplies">
                        <div class="row g-0 p-0 m-0 d-flex align-items-start tootReply" id="displayTootTemplate">
                            <div class="card p-0 m-0">
                                <div class="card-header ">
                                    <div class="card-body p-0 m-0">
                                        <div class="row w-100 p-0 m-0">
                                            <div class="col-1 pt-2 d-flex align-items-center justify-content-center avatar" style="max-width: 4.5em;">
                                                <a rel="external nofollow" href="" class="avatar-link authorLink">
                                                    <img class="m-1 avatarImg avatar" style="height: 2.5em;" src="">
                                                </a>
                                            </div>                                                
                                            <div class="col-6"> 
                                                <p class="text-start p-0 m-0 displayName"><a href="" class="displayNameLink authorLink" target="_blank"><span class="displayNameSpan"></span></a></p>
                                                <p class="text-start p-0 m-0 "><span class="userNameSpan"></span><span class="instanceNameSpan"></span></p>
                                            </div>
                                            <div class="col-5 createdAt"> 
                                                <p class="card-title p-3 m-0 text-end"><a href="" target="_blank" class="createdAtLink"></a></p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="card-body p-0 m-0">
                                    <div class="row w-100 p-0 m-0 ">
                                        <p class="card-title p-3 m-0 text-start content"></p>
                                    </div>
                                </div>
                                <div class="card-body p-0 m-0">
                                    <div class="row w-100 p-0 m-0 attachments">
                                    </div>
                                </div>
                                <footer class="card-footer text-muted" role="contentinfo">
                                    <nav class="row w-100" role="navigation" aria-label="Reply interactions">
                                        <div class="col-2 text-center d-flex align-items-center justify-content-center">
                                            <button type="button" 
                                                    class="btn btn-link p-0 border-0 show-replies-btn" 
                                                    aria-label="Show replies" 
                                                    data-action="show-replies"
                                                    data-post-id="">
                                                <i class="fa-solid fa-comments" aria-hidden="true"></i>
                                            </button>
                                        </div>
                                        <div class="col-2 text-center d-flex align-items-center justify-content-center">
                                            <button type="button" 
                                                    class="btn btn-link p-0 border-0 reply-btn" 
                                                    aria-label="Reply to post" 
                                                    data-action="reply"
                                                    data-post-url="">
                                                <i class="fa-solid fa-reply" aria-hidden="true"></i>
                                            </button>
                                        </div>
                                        <div class="col-2 text-center d-flex align-items-center justify-content-center">
                                            <button type="button" 
                                                    class="btn btn-link p-0 border-0 boost-btn" 
                                                    aria-label="Boost post" 
                                                    data-action="boost"
                                                    data-post-url="">
                                                <i class="fa-solid fa-rocket" aria-hidden="true"></i>
                                            </button>
                                        </div>
                                        <div class="col-2 text-center d-flex align-items-center justify-content-center">
                                            <button type="button" 
                                                    class="btn btn-link p-0 border-0 favorite-btn" 
                                                    aria-label="Favorite post" 
                                                    data-action="favorite"
                                                    data-post-url="">
                                                <i class="fa-regular fa-heart" aria-hidden="true"></i>
                                            </button>
                                        </div>
                                        <div class="col-2 text-center d-flex align-items-center justify-content-center">
                                            <button type="button" 
                                                    class="btn btn-link p-0 border-0 bookmark-btn" 
                                                    aria-label="Bookmark post" 
                                                    data-action="bookmark"
                                                    data-post-url="">
                                                <i class="fa-solid fa-bookmark" aria-hidden="true"></i>
                                            </button>
                                        </div>
                                        <div class="col-2 text-center d-flex align-items-center justify-content-center">
                                            <button type="button" 
                                                    class="btn btn-link p-0 border-0 hide-replies-btn" 
                                                    aria-label="Hide replies" 
                                                    data-action="hide-replies"
                                                    data-post-id="">
                                                <i class="fa-solid fa-eye-slash" aria-hidden="true"></i>
                                            </button>
                                        </div>
                                    </nav>
                                </footer>
                                <div class="card-body p-0 m-0">
                                    <div class="row w-100 p-0 m-0 tootSubReplies">
                                        <!-- insert nested card.-->
                                    </div>  
                                </div>
                            </div>
                        </div>
                    </div>  
                </div>
            </div>
        </div>
    </section>
    <script>
        /**
         * MastodonInteractions class handles all interaction functionality for Mastodon posts
         * including show/hide replies, reply, boost, favorite, and bookmark actions.
         */
        class MastodonInteractions {
            constructor() {
                this.hiddenReplies = new Set();
                this.favoriteStates = new Map();
                this.bookmarkStates = new Map();
                this.boostStates = new Map();
                this.replyStates = new Map();
                this.setupEventListeners();
            }

            /**
             * Extracts the instance URL and toot ID from a Mastodon post URL
             * @param {string} postUrl - The original Mastodon post URL
             * @returns {Object} Object containing instance and tootId
             */
            parsePostUrl(postUrl) {
                try {
                    const url = new URL(postUrl);
                    const instance = `${url.protocol}//${url.host}`;
                    
                    // Extract toot ID from various URL patterns
                    const pathParts = url.pathname.split('/');
                    let tootId = null;
                    
                    // Handle different URL formats:
                    // https://instance.social/@user/123456789
                    // https://instance.social/users/user/statuses/123456789
                    // https://instance.social/web/statuses/123456789
                    
                    if (pathParts.includes('statuses')) {
                        // Find the part after 'statuses'
                        const statusIndex = pathParts.indexOf('statuses');
                        if (statusIndex + 1 < pathParts.length) {
                            tootId = pathParts[statusIndex + 1];
                        }
                    } else {
                        // For @user/tootId format, get the last part
                        tootId = pathParts[pathParts.length - 1];
                    }
                    
                    return { instance, tootId };
                } catch (error) {
                    console.error('Error parsing post URL:', error);
                    return { instance: null, tootId: null };
                }
            }

            /**
             * Constructs the proper Mastodon API URL for interactions
             * @param {string} postUrl - The original post URL
             * @param {string} actionType - The type of action (favourite, reblog, bookmark, reply)
             * @returns {string} The constructed API URL
             */
            buildApiUrl(postUrl, actionType) {
                const { instance, tootId } = this.parsePostUrl(postUrl);
                
                if (!instance || !tootId) {
                    console.error('Could not parse post URL for interaction:', postUrl);
                    return null;
                }
                
                // Build proper Mastodon API endpoints according to official docs
                switch (actionType) {
                    case 'favourite':
                        return `${instance}/api/v1/statuses/${tootId}/favourite`;
                    case 'unfavourite':
                        return `${instance}/api/v1/statuses/${tootId}/unfavourite`;
                    case 'reblog':
                        return `${instance}/api/v1/statuses/${tootId}/reblog`;
                    case 'unreblog':
                        return `${instance}/api/v1/statuses/${tootId}/unreblog`;
                    case 'bookmark':
                        return `${instance}/api/v1/statuses/${tootId}/bookmark`;
                    case 'unbookmark':
                        return `${instance}/api/v1/statuses/${tootId}/unbookmark`;
                    case 'reply':
                        return `${instance}/api/v1/statuses`; // POST endpoint for creating new status
                    default:
                        console.error('Unknown action type:', actionType);
                        return null;
                }
            }

            /**
             * Constructs the fallback interaction URL for browsers without proper authentication
             * @param {string} postUrl - The original post URL
             * @param {string} actionType - The type of action (reblog, like, bookmark, reply)
             * @returns {string} The constructed interaction URL
             */
            buildInteractionUrl(postUrl, actionType) {
                const { instance, tootId } = this.parsePostUrl(postUrl);
                
                if (!instance || !tootId) {
                    console.error('Could not parse post URL for interaction:', postUrl);
                    return postUrl; // Fallback to original URL
                }
                
                // Map action types to the correct interaction types
                const interactionMap = {
                    'favourite': 'like',
                    'reblog': 'reblog', 
                    'bookmark': 'bookmark',
                    'reply': 'reply'
                };
                
                const interactionType = interactionMap[actionType] || actionType;
                return `${instance}/interact/${tootId}?type=${interactionType}`;
            }

            /**
             * Attempts to perform the interaction using the proper Mastodon API
             * Falls back to opening interaction page if API call fails
             * @param {string} postUrl - The original post URL
             * @param {string} actionType - The type of action
             * @param {function} onSuccess - Callback for successful API call
             * @param {function} onError - Callback for failed API call
             */
            async performApiInteraction(postUrl, actionType, onSuccess, onError) {
                const apiUrl = this.buildApiUrl(postUrl, actionType);
                
                if (!apiUrl) {
                    console.error('Could not build API URL for interaction');
                    onError && onError('Invalid API URL');
                    return false;
                }

                try {
                    // First, try to detect if we're on the same instance
                    const { instance } = this.parsePostUrl(postUrl);
                    const currentOrigin = window.location.origin;
                    const sameInstance = instance === currentOrigin;
                    
                    if (!sameInstance) {
                        // Different instance - API call will likely fail due to CORS and auth
                        console.log('Cross-instance interaction detected, skipping API call');
                        onError && onError('Cross-instance interaction requires fallback');
                        return false;
                    }

                    // Note: This will only work if the user is logged into the same instance
                    // and the website has proper CORS configuration
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                            // Note: Authorization Bearer token would need to be obtained through OAuth flow
                            // For now, we rely on session cookies
                        },
                        credentials: 'include', // Include cookies for authentication
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log(`${actionType} API call successful:`, result);
                        onSuccess && onSuccess(result);
                        return true;
                    } else if (response.status === 401) {
                        console.log('API call failed: User not authenticated');
                        onError && onError('Authentication required');
                        return false;
                    } else if (response.status === 403) {
                        console.log('API call failed: Insufficient permissions');
                        onError && onError('Insufficient permissions');
                        return false;
                    } else {
                        throw new Error(`API call failed with status: ${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    if (error.name === 'TypeError' && error.message.includes('CORS')) {
                        console.log('API interaction failed due to CORS policy, falling back to interaction page');
                    } else {
                        console.warn('API interaction failed, falling back to interaction page:', error);
                    }
                    onError && onError(error);
                    return false;
                }
            }

            /**
             * Sets up event listeners for all interaction buttons
             */
            setupEventListeners() {
                // Use event delegation for dynamically created content
                document.addEventListener('click', (event) => {
                    const button = event.target.closest('button[data-action]');
                    if (!button) return;

                    event.preventDefault();
                    event.stopPropagation();

                    const action = button.getAttribute('data-action');
                    const postId = button.getAttribute('data-post-id');
                    const postUrl = button.getAttribute('data-post-url');

                    switch (action) {
                        case 'show-replies':
                            this.handleShowReplies(button, postId);
                            break;
                        case 'hide-replies':
                            this.handleHideReplies(button, postId);
                            break;
                        case 'reply':
                            this.handleReply(button, postUrl, postId);
                            break;
                        case 'boost':
                            this.handleBoost(button, postUrl, postId);
                            break;
                        case 'favorite':
                            this.handleFavorite(button, postUrl, postId);
                            break;
                        case 'bookmark':
                            this.handleBookmark(button, postUrl, postId);
                            break;
                    }
                });
            }

            /**
             * Handles showing replies for a post
             */
            handleShowReplies(button, postId) {
                if (!postId) return;

                const postElement = document.getElementById(postId);
                if (!postElement) return;

                const repliesContainer = postElement.querySelector('.tootReplies, .tootSubReplies');
                if (repliesContainer) {
                    repliesContainer.style.display = 'block';
                    this.hiddenReplies.delete(postId);
                    
                    // Update button states
                    this.updateReplyButtonStates(postElement, true);
                }

                // Add visual feedback
                this.addButtonFeedback(button, 'success');
            }

            /**
             * Handles hiding replies for a post
             */
            handleHideReplies(button, postId) {
                if (!postId) return;

                const postElement = document.getElementById(postId);
                if (!postElement) return;

                const repliesContainer = postElement.querySelector('.tootReplies, .tootSubReplies');
                if (repliesContainer) {
                    repliesContainer.style.display = 'none';
                    this.hiddenReplies.add(postId);
                    
                    // Update button states
                    this.updateReplyButtonStates(postElement, false);
                }

                // Add visual feedback
                this.addButtonFeedback(button, 'info');
            }

            /**
             * Updates the visibility state of show/hide reply buttons
             */
            updateReplyButtonStates(postElement, repliesVisible) {
                const showBtn = postElement.querySelector('.show-replies-btn');
                const hideBtn = postElement.querySelector('.hide-replies-btn');

                if (showBtn && hideBtn) {
                    if (repliesVisible) {
                        showBtn.style.opacity = '0.5';
                        hideBtn.style.opacity = '1';
                        showBtn.setAttribute('aria-pressed', 'true');
                        hideBtn.setAttribute('aria-pressed', 'false');
                    } else {
                        showBtn.style.opacity = '1';
                        hideBtn.style.opacity = '0.5';
                        showBtn.setAttribute('aria-pressed', 'false');
                        hideBtn.setAttribute('aria-pressed', 'true');
                    }
                }
            }

            /**
             * Handles reply action - attempts API call first, falls back to interaction URL
             */
            async handleReply(button, postUrl, postId) {
                if (!postUrl) return;

                // Add loading state
                this.setButtonLoading(button, true);

                // For replies, we would need to prompt for content, so we'll use the interaction URL approach
                // as the API requires the actual reply content to be posted
                const interactionUrl = this.buildInteractionUrl(postUrl, 'reply');
                
                // Open the interaction URL in a new tab for replying
                window.open(interactionUrl, '_blank', 'noopener,noreferrer');
                
                // Remove loading state and add visual feedback
                this.setButtonLoading(button, false);
                this.addButtonFeedback(button, 'primary');
                this.replyStates.set(postId, true);
                this.updateButtonState(button, true);
            }

            /**
             * Handles boost action - attempts API call first, falls back to interaction URL
             */
            async handleBoost(button, postUrl, postId) {
                if (!postUrl) return;

                // Toggle boost state
                const currentState = this.boostStates.get(postId) || false;
                const newState = !currentState;
                
                // Add loading state
                this.setButtonLoading(button, true);

                // Determine the correct action type based on current state
                const actionType = newState ? 'reblog' : 'unreblog';

                // Attempt API interaction first
                const apiSuccess = await this.performApiInteraction(
                    postUrl, 
                    actionType,
                    (result) => {
                        // API success callback
                        console.log('Boost API call successful:', result);
                        this.boostStates.set(postId, result.reblogged || false);
                        this.updateButtonState(button, result.reblogged || false);
                        this.addButtonFeedback(button, result.reblogged ? 'warning' : 'secondary');
                    },
                    (error) => {
                        // API error callback
                        console.warn('Boost API call failed:', error);
                    }
                );

                // If API call failed, fall back to interaction URL
                if (!apiSuccess) {
                    const interactionUrl = this.buildInteractionUrl(postUrl, 'reblog');
                    window.open(interactionUrl, '_blank', 'noopener,noreferrer');
                    
                    // Update local state since we can't know the server state
                    this.boostStates.set(postId, newState);
                    this.updateButtonState(button, newState);
                    this.addButtonFeedback(button, newState ? 'warning' : 'secondary');
                }

                // Remove loading state
                this.setButtonLoading(button, false);
            }

            /**
             * Handles favorite action - attempts API call first, falls back to interaction URL
             */
            async handleFavorite(button, postUrl, postId) {
                if (!postUrl) return;

                // Toggle favorite state
                const currentState = this.favoriteStates.get(postId) || false;
                const newState = !currentState;
                
                // Add loading state
                this.setButtonLoading(button, true);

                // Determine the correct action type based on current state
                const actionType = newState ? 'favourite' : 'unfavourite';

                // Attempt API interaction first
                const apiSuccess = await this.performApiInteraction(
                    postUrl, 
                    actionType,
                    (result) => {
                        // API success callback
                        console.log('Favorite API call successful:', result);
                        this.favoriteStates.set(postId, result.favourited || false);
                        this.updateButtonState(button, result.favourited || false);
                        this.updateFavoriteIcon(button, result.favourited || false);
                        this.addButtonFeedback(button, result.favourited ? 'danger' : 'secondary');
                    },
                    (error) => {
                        // API error callback
                        console.warn('Favorite API call failed:', error);
                    }
                );

                // If API call failed, fall back to interaction URL
                if (!apiSuccess) {
                    const interactionUrl = this.buildInteractionUrl(postUrl, 'favourite');
                    window.open(interactionUrl, '_blank', 'noopener,noreferrer');
                    
                    // Update local state since we can't know the server state
                    this.favoriteStates.set(postId, newState);
                    this.updateButtonState(button, newState);
                    this.updateFavoriteIcon(button, newState);
                    this.addButtonFeedback(button, newState ? 'danger' : 'secondary');
                }

                // Remove loading state
                this.setButtonLoading(button, false);
            }

            /**
             * Handles bookmark action - attempts API call first, falls back to interaction URL
             */
            async handleBookmark(button, postUrl, postId) {
                if (!postUrl) return;

                // Toggle bookmark state
                const currentState = this.bookmarkStates.get(postId) || false;
                const newState = !currentState;
                
                // Add loading state
                this.setButtonLoading(button, true);

                // Determine the correct action type based on current state
                const actionType = newState ? 'bookmark' : 'unbookmark';

                // Attempt API interaction first
                const apiSuccess = await this.performApiInteraction(
                    postUrl, 
                    actionType,
                    (result) => {
                        // API success callback
                        console.log('Bookmark API call successful:', result);
                        this.bookmarkStates.set(postId, result.bookmarked || false);
                        this.updateButtonState(button, result.bookmarked || false);
                        this.addButtonFeedback(button, result.bookmarked ? 'info' : 'secondary');
                    },
                    (error) => {
                        // API error callback
                        console.warn('Bookmark API call failed:', error);
                    }
                );

                // If API call failed, fall back to interaction URL
                if (!apiSuccess) {
                    const interactionUrl = this.buildInteractionUrl(postUrl, 'bookmark');
                    window.open(interactionUrl, '_blank', 'noopener,noreferrer');
                    
                    // Update local state since we can't know the server state
                    this.bookmarkStates.set(postId, newState);
                    this.updateButtonState(button, newState);
                    this.addButtonFeedback(button, newState ? 'info' : 'secondary');
                }

                // Remove loading state
                this.setButtonLoading(button, false);
            }

            /**
             * Updates button visual state based on active/inactive status
             */
            updateButtonState(button, isActive) {
                if (isActive) {
                    button.classList.add('active');
                    button.style.opacity = '1';
                    button.setAttribute('aria-pressed', 'true');
                } else {
                    button.classList.remove('active');
                    button.style.opacity = '0.7';
                    button.setAttribute('aria-pressed', 'false');
                }
            }

            /**
             * Updates favorite button icon between filled and regular heart
             */
            updateFavoriteIcon(button, isFavorited) {
                const icon = button.querySelector('i');
                if (icon) {
                    if (isFavorited) {
                        icon.className = 'fa-solid fa-heart';
                        icon.style.color = '#dc3545'; // Bootstrap danger color
                    } else {
                        icon.className = 'fa-regular fa-heart';
                        icon.style.color = '';
                    }
                }
            }

            /**
             * Adds temporary visual feedback to button
             */
            addButtonFeedback(button, type) {
                const originalClass = button.className;
                button.classList.add('btn-' + type);
                
                setTimeout(() => {
                    button.className = originalClass;
                }, 200);
            }

            /**
             * Sets button loading state with spinner
             */
            setButtonLoading(button, isLoading) {
                if (isLoading) {
                    button.disabled = true;
                    button.setAttribute('aria-busy', 'true');
                    
                    // Store original content
                    if (!button.hasAttribute('data-original-html')) {
                        button.setAttribute('data-original-html', button.innerHTML);
                    }
                    
                    // Add spinner
                    button.innerHTML = '<i class="fa-solid fa-spinner fa-spin" aria-hidden="true"></i>';
                } else {
                    button.disabled = false;
                    button.setAttribute('aria-busy', 'false');
                    
                    // Restore original content
                    const originalHtml = button.getAttribute('data-original-html');
                    if (originalHtml) {
                        button.innerHTML = originalHtml;
                        button.removeAttribute('data-original-html');
                    }
                }
            }

            /**
             * Extracts post ID from button's closest post container
             */
            getPostIdFromButton(button) {
                const postContainer = button.closest('[id]');
                return postContainer ? postContainer.id : null;
            }

            /**
             * Initializes buttons for a newly created post element
             * Called from displayToot and displayTootReply functions
             */
            initializePostButtons(postElement, postData) {
                if (!postElement || !postData) return;

                const postId = postData.id;
                const postUrl = postData.url;

                // Set data attributes for all buttons
                const buttons = postElement.querySelectorAll('button[data-action]');
                buttons.forEach(button => {
                    const action = button.getAttribute('data-action');
                    
                    // Set post-specific data attributes
                    if (action === 'show-replies' || action === 'hide-replies') {
                        button.setAttribute('data-post-id', postId);
                    } else {
                        button.setAttribute('data-post-url', postUrl);
                        button.setAttribute('data-post-id', postId);
                    }

                    // Initialize button states
                    this.initializeButtonState(button, action, postId);
                });

                // Initialize reply visibility state
                this.updateReplyButtonStates(postElement, true);
            }

            /**
             * Initializes individual button state
             */
            initializeButtonState(button, action, postId) {
                switch (action) {
                    case 'favorite':
                        const isFavorited = this.favoriteStates.get(postId) || false;
                        this.updateButtonState(button, isFavorited);
                        this.updateFavoriteIcon(button, isFavorited);
                        break;
                    case 'bookmark':
                        const isBookmarked = this.bookmarkStates.get(postId) || false;
                        this.updateButtonState(button, isBookmarked);
                        break;
                    case 'boost':
                        const isBoosted = this.boostStates.get(postId) || false;
                        this.updateButtonState(button, isBoosted);
                        break;
                    default:
                        this.updateButtonState(button, false);
                }
            }
        }

        // Initialize the MastodonInteractions instance
        let mastodonInteractions;

        function createCarouselNew(media_attachments, id) {

            console.log("createCarouselNew()");
            console.log(media_attachments);


            // Create a carousel card
            function createCard(imageID, imagePreviewUrl, imageUrl, imagePositionX, imagePositionY, text) {
                var card = document.createElement('div');
                card.setAttribute('class', 'card ');
                var a = document.createElement('a');
                a.setAttribute('href', imageUrl);
                a.setAttribute('target', '_blank');
                var img = document.createElement('img');
                img.setAttribute('src', imagePreviewUrl);
                img.setAttribute('class', 'object-fit-cover card-img-top');
                img.setAttribute('alt', text);
                //TODO: Add Image Set.  This is for the lazy loading of images.
                //TODO Add BlurHash.  This is for the lazy loading of images.

                img.setAttribute('style', 'object-position: ' + imagePositionX + ' ' + imagePositionY+";" );
                a.appendChild(img);
                card.appendChild(a);

                var cardBody = document.createElement('div');
                cardBody.setAttribute('class', 'card-body');
                var cardTitle = document.createElement('p');
                cardTitle.setAttribute('class', 'h5 card-title');
                cardTitle.textContent = text;
                //var cardText = document.createElement('p');
                //cardText.setAttribute('class', 'card-text');
                //cardText.textContent = text;
                //This is for the last updated text, however that isn't used.  Perhaps this can be reused for something else.
                //var cardTextSmall = document.createElement('p');
                //cardTextSmall.setAttribute('class', 'card-text');
                //var small = document.createElement('small');
                //small.setAttribute('class', 'text-muted');
                //small.textContent = lastUpdated;
                //cardTextSmall.appendChild(small);

                cardBody.appendChild(cardTitle);
                //cardBody.appendChild(cardText);
                //cardBody.appendChild(cardTextSmall);
                card.appendChild(cardBody);

                return card;
            }


            // Function to create a carousel item
            function createCarouselItem(active, items) {
                var item = document.createElement('div');
                item.setAttribute('class', `carousel-item ${active ? 'active' : ''}`);
                var cardGroup = document.createElement('div');
                cardGroup.setAttribute('class', 'card-group');
                item.appendChild(cardGroup);

                if (items) {
                    items.forEach(function(currentItem) {

                        console.log("tems.forEach(function(currentItem) {");
                        console.log(currentItem);

                        var imageUrl = currentItem.imageUrl;
                        var imagePreviewUrl = currentItem.imagePreviewUrl;
                        var text = currentItem.text;
                        var imageID = currentItem.id;
                        var imagePositionX = currentItem.imagePositionX;
                        var imagePositionY = currentItem.imagePositionY;

                        cardGroup.appendChild(createCard(imageID, imagePreviewUrl, imageUrl, imagePositionX, imagePositionY, text));
                    });
                }

                return item;
            }

            // Function to create a button for the indicators
            function createButton(index, isActive) {
                var button = document.createElement('button');
                    button.setAttribute('type', 'button');
                    button.dataset.bsTarget = '#' + 'carousel-' + id
                    button.dataset.bsSlideTo = index;
                    button.setAttribute('class', isActive ? 'active carousel-button' : 'carousel-button');
                    button.setAttribute('aria-label', `Slide ${index + 1}`);
                if (isActive) {
                    button.setAttribute('aria-current', 'true');
                }
                return button;
            }

            // Create the main carousel container
            var carousel = document.createElement('div');
                carousel.setAttribute('id', 'carousel-' + id);
                carousel.setAttribute('class', 'carousel slide');
                carousel.dataset.bsRide = 'false';

            // Create the carousel indicators container
            var carouselIndicators = document.createElement('div');
                carouselIndicators.setAttribute('class', 'carousel-indicators row w-100 p-0 m-0 position-relative');
                carousel.appendChild(carouselIndicators);

            // Create the carousel inner container
            var carouselInner = document.createElement('div');
                carouselInner.setAttribute('class', 'carousel-inner');
                carousel.appendChild(carouselInner);


            var CarouselArray = [];
            var numberOfButtons = 0;
            var isFirstItem = true;
            for (var i = 0; i < media_attachments.length; i++) {
                var ImageID = media_attachments[i].id;
                var imageUrl = media_attachments[i].url;
                var imagePreviewUrl = media_attachments[i].preview_url;
                var text = media_attachments[i].text;
                var imagePositionX = (media_attachments[i].meta.focus.x * 100) + '%';
                var imagePositionY = (media_attachments[i].meta.focus.y * 100) + '%';

                console.log (imagePositionX + " " + imagePositionY);
                console.log ( (media_attachments[i].meta.focus.x * 100) + '%' + " "+ (media_attachments[i].meta.focus.y * 100) + '%');
                console.log ( media_attachments[i].meta.focus.x + " "+ media_attachments[i].meta.focus.y );


                var item = {
                    id: ImageID,
                    imageUrl: imageUrl,
                    imagePreviewUrl: imagePreviewUrl,
                    imagePositionX: imagePositionX,
                    imagePositionY: imagePositionY,
                    text: text,
                };

                CarouselArray.push(item);

                // If tempArray has 3 items or if this is the last item
                if (CarouselArray.length === 3 || i === media_attachments.length - 1) {

                    // Add items to the carousel inner container
                    carouselInner.appendChild(createCarouselItem(isFirstItem, CarouselArray));
                    // Reset tempArray
                    CarouselArray = [];

                    if (numberOfButtons === 0) {
                        // Add buttons to the carousel indicators for every 3 images
                        carouselIndicators.appendChild(createButton(numberOfButtons, true));
                    } else {
                        carouselIndicators.appendChild(createButton(numberOfButtons, false));
                    }
                    numberOfButtons += 1;

                    isFirstItem = false
                }
            }

            // Append the carousel to the document body or a specific container
            return carousel;
        }

        /**
         * Loads a "toot" (a post or comment) from a given URL and displays it in a specified HTML element.
         *
         * @param {string} url - The URL of the toot.
         * @param {string|HTMLElement} element - The ID of an HTML element or the HTML element itself where the toot will be displayed.
         *
         * The function sends a GET request to the Mastodon API to retrieve the toot. The URL of the API endpoint is determined based on the given URL. If the URL does not contain "/api/v" or "/m/", the function modifies it to conform to the expected format of the API endpoint URL.
         *
         * When the request is successful, the function parses the response as JSON and passes the resulting object along with the specified element to the `displayToot` function.
         *
         * @returns {void}
         */        
         function loadTootThread(url, element) {
            var xmlhttp = new XMLHttpRequest();
            if (url.indexOf("/api/v") == -1 && url.indexOf("/m/") == -1) {
                if (url.indexOf("http") != 0) {
                    // console.log("This doesn't look like a valid URL: " + url);
                    url = "https://" + url;
                }
                var splitUrl = url.split("/");
                // url = splitUrl[0] + '//' + splitUrl[2] + '/b api/v1/statuses/';
                url = splitUrl[0] + "//" + splitUrl[2] + "/api/v1/statuses/";
                // support different URL syntaxes for links to toots
                if (splitUrl[3] && splitUrl[3] == "users") {
                    url += splitUrl[6];
                } else if (splitUrl[3] && splitUrl[3] == "web") {
                    url += splitUrl[5];
                } else {
                    url += splitUrl[4];
                }
                if (splitUrl[3] == "notes") {
                    // Shuttlecraft
                    url = splitUrl[0] + "//" + splitUrl[2] + "/m/" + splitUrl[4];
                }
                lastUrl = url;
                // console.log(url);
            }
        
            xmlhttp.onreadystatechange = function () {
                //console.log('xmlhttp.onreadystatechange()');
                if (this.readyState == 4 && this.status == 200) {
                var myArr = JSON.parse(this.responseText);
                displayToot(myArr, element);
                }
            };
            xmlhttp.open("GET", url, true);
            xmlhttp.setRequestHeader(
                "Accept",
                'application/ld+json; profile="https://www.w3.org/ns/activitystreams"'
            );
            xmlhttp.send();
        }

        /**
         * Loads the replies to a "toot" (a post or comment) and displays them in a specified HTML element.
         *
         * @param {Object} arr - An object containing the data of the toot. This parameter is currently not used in the function.
         * @param {string|HTMLElement} element - The ID of an HTML element or the HTML element itself where the replies will be displayed.
         *
         * The function sends a GET request to the Mastodon API to retrieve the replies to the toot. The URL of the API endpoint is determined based on the last URL that was used to load a toot. If the last URL contains "/m/", the function appends "/replies" to it, otherwise it appends "/context".
         *
         * When the request is successful, the function parses the response as JSON and passes the resulting object along with the specified element to the `displayTootReplies` function.
         *
         * @returns {void}
         */        
         function loadTootReplies(arr, element) {
            var xmlhttp = new XMLHttpRequest();
        
            // TODO: figure out the URL
            // var url = 'https://mastodon.social/api/v1/statuses/108195817029536656/context';
            var url = lastUrl + "/context";
            if (lastUrl.indexOf("/m/") != -1) {
                url = lastUrl + "/replies";
            }
            if (lastRepliesUrl == url) {
                // TODO: this is hinky when considering multiple different ways you can request original toot URL
                // return;
            }
            lastRepliesUrl = url;
        
            xmlhttp.onreadystatechange = function () {
                //console.log('xmlhttp.onreadystatechange()');
                if (this.readyState == 4 && this.status == 200) {
                var myArr = JSON.parse(this.responseText);
                displayTootReplies(myArr, element);
                }
            };
            xmlhttp.open("GET", url, true);
            xmlhttp.setRequestHeader(
                "Accept",
                'application/ld+json; profile="https://www.w3.org/ns/activitystreams"'
            );
            xmlhttp.send();
        }
 
        /**
        * Displays a "toot" (a post or comment) in a specified HTML element.
        *
        * @param {Object} arr - An object containing the data of the toot.
        * The arr object should have the following properties:
        * - account: An object containing the account information of the user who made the toot. If this property is not present, the function will try to use the attributedTo property instead.
        * - created_at: The date and time when the toot was created. If this property is not present, the function will use the published property instead.
        * - url: The URL of the toot.
        * - content: The content of the toot.
        *
        * @param {string|HTMLElement} element - The ID of an HTML element or the HTML element itself where the toot will be displayed.
        *
        * The function fills the specified element with the toot data, including the author's avatar, display name, username, instance name, the toot content, and the time since the toot was created. It also sets the href attribute of all elements with the class "authorLink" to the URL of the author's account.
        *
        * @returns {void}
        */        
        function displayToot(arr, element) {
            console.log("displayToot()");
            console.log(arr);
            // var displayJson = JSON.stringify(arr, null, 2);
            // handle missing / alternate variables
            if (!arr.account) {
                // handling data likely from Shuttlecraft
                var display_name = arr.attributedTo.split("/");
                display_name = display_name[display_name.length - 1];
                arr.account = {
                    url: arr.attributedTo,
                    avatar: "",
                    display_name: display_name,
                    username: display_name,
                };
            }
            if (!arr.created_at) {
                arr.created_at = arr.published;
            }
            // figure out multiple authors in comments thread
            var instanceName = arr.url
                .replaceAll("http://", "")
                .replaceAll("https://", "")
                .split("/")[0];
            originalAuthorId = arr.account.id;
            previousAuthorId = arr.account.id;
            originalAuthorUsername = arr.account.username;
            originalAuthorUsernameWithInstance = "@" + originalAuthorUsername + "@" + instanceName;
            topOfThreadId = arr.id;
            var displayToot;
            if (typeof element === "string") {
                displayToot = document.getElementById(element);
            }
            // backup the reply template, then remove old replies
            if (!tootReplyHtml) {
                tootReplyHtml = document.getElementById("displayTootTemplate").outerHTML + "";
            }
            // actually display content
            document.getElementsByClassName("tootReplies")[0].innerHTML = "";
            function ge(cn) {
                return displayToot.getElementsByClassName(cn)[0];
            }
            // ge('authorLink').href = arr.account.url;
            displayToot.id = arr.id; // new for trees

            if (arr.media_attachments && arr.media_attachments.length > 0) {
                var attachments = createCarouselNew(arr.media_attachments, arr.id);
                ge("attachments").appendChild(attachments);
            } else {
                ge("attachments").style.display = "none";
            }

            ge("avatarImg").src = "";
            ge("avatarImg").src = arr.account.avatar;
            ge("displayNameSpan").innerHTML = arr.account.display_name;
            ge("userNameSpan").innerHTML = "@" + arr.account.username;
            ge("instanceNameSpan").innerHTML = "@" + instanceName;
            ge("content").innerHTML = formatToot(arr.content);
            ge("createdAtLink").innerHTML = timeSince(arr.created_at);
            ge("createdAtLink").href = arr.url;
            var links = document.getElementsByClassName("authorLink");
            for (var i = 0; i < links.length; i++) {
                links[i].href = arr.account.url;
            }
            
            // Initialize interaction buttons with the MastodonInteractions class
            if (mastodonInteractions) {
                mastodonInteractions.initializePostButtons(displayToot, arr);
            }
            
            firstPost = arr;
            loadTootReplies(arr, document.getElementsByClassName("tootReplies")[0]);
            // console.log('Displayed original toot');
        }

        function getImageFromBlurHash(blurhash) {
            const pixels = decode(blurhash, width, height);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);
            imageData.data.set(pixels);
            ctx.putImageData(imageData, 0, 0);
            return canvas.toDataURL();
        }

        /**
         * Calculates the time elapsed since a given date and returns a string representing this duration.
         *
         * @param {string|Date} date - The date from which the elapsed time is calculated. Can be a Date object or a string that can be parsed into a Date object.
         *
         * @returns {string} A string representing the time elapsed since the given date. The string is in the format of "Xy", "Xm", "Xd", "Xh", "Xm", or "Xs", where X is the amount of time and y, m, d, h, m, and s stand for year, month, day, hour, minute, and second, respectively. If the elapsed time is exactly 1 unit, the unit is singular (e.g., "1y", "1m", etc.).
         *
         * @example
         * // returns "1y" if the current date is exactly one year after January 1, 2020
         * timeSince("2020-01-01T00:00:00Z");
         */        
         function timeSince(date) {
            var seconds = Math.floor((new Date() - new Date(date)) / 1000);

            var interval = seconds / 31536000;

            if (interval > 1) {
                return Math.floor(interval) + " y";
            } else if (interval === 1) {
                return "1y";
            }
            interval = seconds / 2592000;
            if (interval > 1) {
                return Math.floor(interval) + " mon";
            } else if (interval === 1) {
                return "1m";
            }
            interval = seconds / 86400;
            if (interval > 1) {
                return Math.floor(interval) + " d";
            } else if (interval === 1) {
                return "1d";
            }
            interval = seconds / 3600;
            if (interval > 1) {
                return Math.floor(interval) + " h";
            } else if (interval === 1) {
                return "1h";
            }
            interval = seconds / 60;
            if (interval > 1) {
                return Math.floor(interval) + " min";
            } else if (interval === 1) {
                return "1m";
            }
            return Math.floor(seconds) === 1 ? "1s" : Math.floor(seconds) + "s";
        }

        /**
         * This function creates and displays a comment or reply in a thread.
         * 
         * @param {string|HTMLElement} element - The ID of an HTML element or the HTML element itself where the comment will be displayed.
         * @param {Object} arr - An object containing the data of the comment.
         * 
         * The arr object should have the following properties:
         * - account: An object containing the account information of the user who made the comment. If this property is not present, the function will try to use the actor property instead.
         * - created_at: The date and time when the comment was created. If this property is not present, the function will use the published property instead.
         * - url: The URL of the comment. If this property is not present, the function will use the note.url property instead.
         * - content: The content of the comment. If this property is not present, the function will use the note.content property instead.
         * - in_reply_to_id: The ID of the comment that this comment is replying to.
         * 
         * The function creates an HTML element for the comment, fills it with the comment data, and appends it to the specified element. It also handles indentation for nested replies.
         * 
         * @returns {HTMLElement} The HTML element of the comment.
         */        
         function displayTootReplies(threadArr, element) {
            console.log("displayTootReplies()");
            console.log(threadArr);
            // var displayJson = JSON.stringify(arr, null, 2);
            var arr;
            //console.log(baseElement);
            // for Shuttlecraft
            if (!threadArr.descendants) {
                threadArr = { descendants: threadArr };
            }
    
            function compareTootDates(a, b) {
                if (a.created_at < b.created_at) {
                    return -1;
                }
                if (a.created_at > b.created_at) {
                    return 1;
                }
                return 0;
            }
        
            function sortRepliesByDate(arr) {
                var returnArr = [];
                for (var i = 0; i < arr.length; i++) {
                    returnArr[i] = arr[i];
                }
                // first sort by data may be redundant
                returnArr.sort(compareTootDates);
                return returnArr;
            }
        
            threadArr.descendants = sortRepliesByDate(threadArr.descendants); // sortRepliesIntoTree(threadArr.descendants);
        
            threadArr = threadArr.descendants;
            for (var i = 0; i < threadArr.length; i++) {
                displayTootReply(threadArr[i], element);
            }
        
            // console.log('Displayed ' + threadArr.descendants.length + ' replies');
        }

        /**
         * Displays a reply to a "toot" (a post or comment) in a specified HTML element.
         *
         * @param {Object} arr - An object containing the data of the reply.
         * The arr object should have the following properties:
         * - account: An object containing the account information of the user who made the reply. If this property is not present, the function will try to use the actor property instead.
         * - created_at: The date and time when the reply was created. If this property is not present, the function will use the published property instead.
         * - url: The URL of the reply.
         * - content: The content of the reply.
         * - in_reply_to_id: The ID of the toot that this reply is replying to.
         *
         * @param {string|HTMLElement} element - The ID of an HTML element or the HTML element itself where the reply will be displayed.
         *
         * The function fills the specified element with the reply data, including the author's avatar, display name, username, instance name, the reply content, and the time since the reply was created. It also sets the href attribute of all elements with the class "authorLink" to the URL of the author's account.
         *
         * The function handles indentation for nested replies. The indentation level is determined based on the ID of the toot that the reply is replying to.
         *
         * @returns {HTMLElement} The HTML element of the reply.
         */
        function displayTootReply(arr, element) {

            console.log("displayTootReply()");
            console.log(arr);

            if (typeof element === "string") {
                baseElement = document.getElementById(element);
            } else {
                baseElement = element;
            }
        
            // handle missing / alternate variables
            if (!arr.account) {
                // handling data likely from Shuttlecraft
                display_name = arr.actor.name;
                arr.account = {
                url: arr.actor.url,
                avatar: arr.actor.image.url,
                display_name: arr.actor.name,
                username: arr.actor.preferredUsername,
                };
            }
            if (!arr.created_at) {
                arr.created_at = arr.published;
            }
            if (!arr.url) {
                arr.url = arr.note.url;
            }
            if (!arr.content) {
                arr.content = arr.note.content;
            }
        
            var instanceName = arr.url
                .replaceAll("http://", "")
                .replaceAll("https://", "")
                .split("/")[0];
            var displayToot = document.createElement("div");
            displayToot.innerHTML = tootReplyHtml;
            function ge(cn) {
                return displayToot.getElementsByClassName(cn)[0];
            }
            var contentObj = ge("content");
            contentObj.innerHTML = formatToot(arr.content);
            if (contentObj.innerText.indexOf(originalAuthorUsernameWithInstance) == 0) {
                // console.log("Post starts with original author's username");
                contentObj.getElementsByTagName("a")[0].style.display = "none";
            }
            // console.log(displayToot);
            baseElement.appendChild(displayToot);
            // when someone else comments and jumps into the thread, show their info
            if (!(combineRepliesFromSameAuthor && arr.account.id == previousAuthorId)) {
                // TODO: promising but needs refinement
                if (arr.in_reply_to_id == topOfThreadId) {
                    indentCount == indentCountDefault;
                }
                if (arr.in_reply_to_id == previousTootId) {
                    indentCount++;
                } else if (arr.in_reply_to_id == previousParentTootId) {
                    // do nothing
                } else {
                    // OLD -- indentCount--;
                    indentCount = getIndentCount(arr.in_reply_to_id);
                }
                if (indentCount <= indentCountDefault) {
                    indentCount = indentCountDefault;
                }
        
                // displayToot.style.marginLeft = '10px'; // don't need to increase over time -- (indentCount*5) + 'px'; // TODO: magic number
                displayToot.id = arr.id; // new for trees
                displayToot.className = "displayTootAndReplies";
                //ge("author").style.display = "grid";

                if (arr.media_attachments && arr.media_attachments.length > 0) {
                    var attachments = createCarouselNew(arr.media_attachments, arr.id);
                    ge("attachments").appendChild(attachments);
                } else {
                    ge("attachments").style.display = "none";
                }

                ge("authorLink").href = arr.account.url;
                ge("avatarImg").src = "";
                ge("avatarImg").src = arr.account.avatar;
                ge("displayNameSpan").innerHTML = arr.account.display_name;
                ge("userNameSpan").innerHTML = "@" + arr.account.username;
                ge("instanceNameSpan").innerHTML = "@" + instanceName;
                ge("createdAtLink").innerHTML = timeSince(arr.created_at);
                ge("createdAtLink").href = "#url=" + arr.url; // blog
                var links = displayToot.getElementsByClassName("authorLink");
                for (var n = 0; n < links.length; n++) {
                    links[n].href = arr.account.url;
                }
                
                // Initialize interaction buttons for this reply
                if (mastodonInteractions) {
                    mastodonInteractions.initializePostButtons(displayToot, arr);
                }
            } else {
                // ge("author").style.display = "none";
            }
            previousAuthorId = arr.account.id;
            previousTootId = arr.id;
            previousParentTootId = arr.in_reply_to_id;
            setIndentCount(arr.in_reply_to_id, indentCount);
            bulkTootReplyHtml += displayToot.innerHTML;
            displayToot.style.display = "block";
        
            // Use HTML hierarchy to show embedded replies
            if (arr.in_reply_to_id) {
                var potentialParentElement = document.getElementById(arr.in_reply_to_id);
                if (potentialParentElement) {
                //blog
                potentialParentElement.appendChild(displayToot);
                }
            }
        
            return displayToot;
        }
    
        function setIndentCount(id, count) {
            indentCountPerId[id] = count;
        }

        function getIndentCount(id) {
            if (indentCountPerId[id]) {
                return indentCountPerId[id];
            }
            return indentCountDefault; // TODO: could be -1 or some error code?
        }
    
        function formatToot(html) {
            if (html.indexOf("<p>") != 0) {
                html = "<p>" + html + "</p>";
            }
            html = html.replaceAll("<br>", "</p><p>");
            return html;
        }

        /**
         * Retrieves the value of a specified variable from the URL hash.
         *
         * @param {string} variable - The name of the variable to retrieve its value.
         *
         * The function parses the URL hash (the part of the URL that follows the # symbol) as a query string. It splits the query string into key-value pairs, and for each pair, it decodes the key and the value from the URL-encoded format and compares the key with the specified variable. If a match is found, it returns the corresponding value.
         *
         * @returns {string} The value of the specified variable. If the variable is not found in the URL hash, it returns an empty string.
         *
         * @example
         * // returns "value" if the URL hash is "#variable=value"
         * getHashVariable("variable");
         */
         function getHashVariable(variable) {
            query = window.location.hash.substr(1);
            vars = query.split("&");
            for (i = 0; i < vars.length; i++) {
                pair = vars[i].split("=");
                if (decodeURIComponent(pair[0]) == variable) {
                return decodeURIComponent(pair[1]);
                }
            }
            return "";
        }

        // Examples:
        // loadToot('https://mastodon.social/@patrickmcurry/108195817029536656','displayToot'); // Load via user-face URL
        // loadToot('https://mastodon.social/api/v1/statuses/108195817029536656','displayToot'); // Load via API URL
    

        /**
         * Processes the URL hash and loads a "toot" (a post or comment) from a specified URL or a default URL.
         *
         * The function retrieves the value of the "url" variable from the URL hash. If the value is not an empty string and is different from the last URL that was used to load a toot, the function updates the last URL and loads the toot from the new URL. If the value is an empty string or the same as the last URL, the function loads the toot from a default URL.
         *
         * The default URL is "https://{{site.mastodon_comments.host}}/@Ted/{{page.mastodon-post-id}}", where {{site.mastodon_comments.host}} and {{page.mastodon-post-id}} are placeholders that should be replaced with the actual values.
         *
         * The loaded toot is displayed in an HTML element with the ID "displayToot".
         *
         * This function is called when the window is loaded and when the URL hash changes.
         *
         * @returns {void}
         */
         function processHash() {	
            var url = getHashVariable("url");	
            if (url != "" && url != lastUrl) {	
                lastUrl = url;	
                loadTootThread(url, "displayToot");	
            } else {	
                loadTootThread(	
                    "https://{{site.mastodon_comments.host}}/@Ted/{{page.mastodon-post-id}}",	
                    "displayToot"	
                );	
            }	
        }
        /**
         * Handles the click event on a reply in a comment thread.
         *
         * @param {HTMLElement} element - The reply that was clicked.
         *
         * The function checks if the clicked reply has a great-grandparent element. If it does, the function modifies the great-grandparent element's style to hide the other replies and adds a "Show Replies" button.
         *
         * Specifically, it sets the height of the great-grandparent element to "14px", the overflow property to "hidden", and the backgroundColor property to "#eeeeee", effectively hiding the other replies and highlighting the clicked reply. It then prepends the "Show Replies" button to the great-grandparent element. The HTML of the "Show Replies" button is retrieved from an element with the ID "showTootTemplate".
         *
         * @returns {boolean} Always returns false. This can be used to prevent the default action of the click event.
         */        
         function clickOnReply(element) {
            //console.log(element);
            if (
                element.parentElement &&
                element.parentElement.parentElement &&
                element.parentElement.parentElement.parentElement &&
                element.parentElement.parentElement.parentElement.parentElement &&
                true
            ) {
                var elem = element.parentElement.parentElement.parentElement.parentElement;
                elem.style.height = "14px"; // 'none';
                elem.style.overflow = "hidden";
                elem.style.backgroundColor = "#eeeeee";
                var showHtml = document.getElementById("showTootTemplate").innerHTML;
                //console.log(showHtml);
                elem.innerHTML = showHtml + elem.innerHTML;
                return false;
            }
        }
    
        /**
         * Handles the click event on a "Show Replies" button in a comment thread.
         *
         * @param {HTMLElement} element - The "Show Replies" button that was clicked.
         *
         * The function checks if the clicked button has a grandparent element. If it does, the function modifies the grandparent element's style to show the hidden replies and removes the "Show Replies" button.
         *
         * Specifically, it sets the height and overflow properties of the grandparent element to their default values, and the backgroundColor property to an empty string, effectively removing any previously applied background color. It then removes the first element with the class "showReplies" from the grandparent element.
         *
         * @returns {boolean} Always returns false. This can be used to prevent the default action of the click event.
         */
        function clickOnReplyShow(element) {
            //console.log(element);
            if (element.parentElement && element.parentElement.parentElement && true) {
                var elem = element.parentElement.parentElement;
                elem.style.height = "";
                elem.style.overflow = "show";
                elem.style.backgroundColor = "";
                elem.getElementsByClassName("showReplies")[0].outerHTML = "";
                return false;
            }
        }
        var originalAuthorId;
        var originalAuthorUsername;
        var originalAuthorUsernameWithInstance;
        var previousAuthorId;
        var lastUrl;
        var lastRepliesUrl;
        var tootReplyHtml;
   
        var topOfThreadId = -1;
        var firstPost;
   
        var combineRepliesFromSameAuthor = false; // changed for /tree -- different from /thread
        var indentCountDefault = 1;
    
        var baseElement;
        var indentCount = indentCountDefault;
        var previousTootId = -1;
        var previousParentTootId = -1;

        var stackObjects = [];
        var stackIndexes = [];
        var stackElements = [];
        var currentIndex = 0;
    
        var bulkTootReplyHtml = "";
        var lastPostElem;
        var skippedFirst = false;

        var indentCountPerId = [];

        // Initialize MastodonInteractions and load content when window loads
        window.onload = function() {
            mastodonInteractions = new MastodonInteractions();
            processHash();
        };	
    </script>






{% else %}
    <section id="comments" class="article-content">
        <h2 id="Comments-Header">Comments</h2>
        <p>This post does not have a link to the Fediverse or Mastodon.  Overtime I will add a link. Until that time, comments have been turned off.</p>
    </section>
{% endif %}