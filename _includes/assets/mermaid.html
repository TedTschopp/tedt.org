<!-- Mermaid.js loader: lazy-loads only if diagrams are present (code fences or data-mermaid attributes)
  Features:
    • Lazy script injection only when needed
    • Light/Dark theme adaptation via data-bs-theme
    • Custom palette injected through buildMermaidConfig (WCAG-conscious)
    • Source <details> panel with copy button
    • Normalizes <br> tags inside code blocks/attributes to newline for Mermaid labels
    • Provides semantic CSS classes you can reference in diagrams:
      classDef core  fill:#eef2ff,stroke:#6366f1,stroke-width:2px,color:#312e81;
      classDef chat  fill:#f0f9ff,stroke:#0ea5e9,stroke-width:2px,color:#075985;
      classDef flow  fill:#fff7ed,stroke:#fb923c,stroke-width:2px,color:#7c2d12;
      classDef agent fill:#f0fdf4,stroke:#22c55e,stroke-width:2px,color:#14532d;
      classDef note  fill:#ffffff,stroke:#94a3b8,stroke-dasharray:3 3,color:#334155;
    • To enable in a post front matter: mermaid: true
-->
<script>
  (function(){
    const MERMAID_CDN = 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js';

    // Selectors that indicate a diagram exists on the page
    const fenceSelector = 'pre > code.language-mermaid, pre > code.mermaid';
    const attrSelector = '[data-mermaid]';

    function findRawBlocks(){
      return Array.from(document.querySelectorAll(fenceSelector));
    }

    function findAttrBlocks(){
      return Array.from(document.querySelectorAll(attrSelector));
    }

    function haveAnyDiagrams(){
      return findRawBlocks().length > 0 || findAttrBlocks().length > 0;
    }

    function ensureScript(cb){
      if (window.mermaid) { cb(); return; }
      // Prevent duplicate loads
      if (document.querySelector('script[data-mermaid-loader]')) {
        // Poll until available
        const poll = setInterval(()=>{ if (window.mermaid){ clearInterval(poll); cb(); } }, 50);
        return;
      }
      const s = document.createElement('script');
      s.src = MERMAID_CDN;
      s.defer = true;
      s.setAttribute('data-mermaid-loader','');
      s.onload = cb;
      s.onerror = ()=>console.warn('Mermaid script failed to load:', MERMAID_CDN);
      document.head.appendChild(s);
    }

    function currentTheme(){
      return (document.documentElement.getAttribute('data-bs-theme')==='dark' ? 'dark' : 'default');
    }

    function buildMermaidConfig(){
      const isDark = currentTheme()==='dark';
      // Base palette chosen for WCAG-ish contrast against typical bg
      const palette = isDark ? {
        primary: '#818cf8', // brighter node fill for contrast
        primaryLight: '#6366f1',
        primaryText: '#0f172a',
        secondary: '#38bdf8',
        secondaryLight: '#0ea5e9',
        secondaryText: '#082f49',
        accent: '#4ade80',
        accentLight: '#22c55e',
        accentText: '#052e16',
        warn: '#fb923c',
        warnLight: '#f97316',
        warnText: '#431407',
        noteBg: '#1e293b',
        noteBorder: '#64748b',
        tool: '#c084fc',
        toolBorder: '#a855f7',
        memory: '#f9a8d4',
        memoryBorder: '#f472b6',
        planner: '#bef264',
        plannerBorder: '#84cc16'
      } : {
        primary: '#4f46e5',
        primaryLight: '#6366f1',
        primaryText: '#ffffff',
        secondary: '#0284c7',
        secondaryLight: '#0ea5e9',
        secondaryText: '#ffffff',
        accent: '#16a34a',
        accentLight: '#22c55e',
        accentText: '#ffffff',
        warn: '#f97316',
        warnLight: '#fb923c',
        warnText: '#ffffff',
        noteBg: '#ffffff',
        noteBorder: '#94a3b8',
        tool: '#9333ea',
        toolBorder: '#7e22ce',
        memory: '#db2777',
        memoryBorder: '#be185d',
        planner: '#65a30d',
        plannerBorder: '#4d7c0f'
      };
      return {
        startOnLoad: false,
        securityLevel: 'strict',
        theme: currentTheme(),
        themeVariables: {
          primaryColor: palette.primaryLight,
          primaryTextColor: palette.primaryText,
            primaryBorderColor: palette.primary,
          lineColor: palette.secondary,
          secondaryColor: palette.secondaryLight,
          tertiaryColor: palette.accentLight,
          tertiaryTextColor: palette.accentText,
          noteBkgColor: palette.noteBg,
          noteTextColor: isDark ? '#e2e8f0' : '#334155',
          noteBorderColor: palette.noteBorder,
          fontFamily: 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif',
          edgeLabelBackground: 'transparent'
        }
      };
    }

    function initMermaid(){
      if (!window.mermaid) return;
      mermaid.initialize(buildMermaidConfig());
    }

    function convertRawCodeBlocks(){
      const raw = findRawBlocks();
      raw.forEach(code => {
        if (code.parentElement && code.parentElement.classList.contains('mermaid')) return; // already processed
        const pre = code.parentElement;
        if (!pre) return;
        let src = code.textContent; // original user code
        // Normalize common HTML line break tags to literal newlines for mermaid label rendering
        src = src.replace(/<br\s*\/?>(\r?\n)?/gi, '\n');
        const div = document.createElement('div');
        div.className = 'mermaid';
        div.textContent = src.trim();
        // store original untrimmed in data attribute to reproduce user formatting in panel
        div.setAttribute('data-mermaid-source', src);
        pre.replaceWith(div);
      });
    }

    function convertAttrBlocks(){
      const attrBlocks = findAttrBlocks();
      attrBlocks.forEach(el => {
        // If element already a mermaid container skip
        if (el.classList.contains('mermaid')) return;
        const code = el.getAttribute('data-mermaid');
        if (!code) return;
        // Allow using the element itself as container
        el.classList.add('mermaid');
        let processed = code.replace(/<br\s*\/?>(\r?\n)?/gi, '\n');
        if (!el.textContent.trim()) {
          el.textContent = processed.trim();
        }
        el.setAttribute('data-mermaid-source', processed);
      });
    }

    /**
     * After diagrams rendered, attach a <details> element containing the raw source + copy button.
     * Idempotent: will not duplicate panels if already present.
     */
    function ensureSourcePanels(){
      document.querySelectorAll('.mermaid.rendered, .mermaid:not(.mermaid-loading)').forEach(diagram => {
        // If already wrapped in composite skip
        if (diagram.parentElement && diagram.parentElement.classList.contains('mermaid-composite')) return;

        const src = diagram.getAttribute('data-mermaid-source') || diagram.textContent || '';
        if (!src.trim()) return;

        // Build composite wrapper
        const composite = document.createElement('div');
        composite.className = 'mermaid-composite';

        // Insert composite before diagram, then move diagram inside
        diagram.parentNode.insertBefore(composite, diagram);
        composite.appendChild(diagram);

        // Source panel (details)
        const details = document.createElement('details');
        details.className = 'mermaid-source-panel';
        details.setAttribute('data-collapsed', 'true');
        const summary = document.createElement('summary');
        summary.textContent = 'Mermaid Source';
        details.appendChild(summary);

        const wrapper = document.createElement('div');
        wrapper.className = 'mermaid-source-wrapper';
        const actions = document.createElement('div');
        actions.className = 'mermaid-source-actions';
        const copyBtn = document.createElement('button');
        copyBtn.type = 'button';
        copyBtn.className = 'mermaid-copy-btn';
        copyBtn.setAttribute('aria-label', 'Copy mermaid source');
        copyBtn.textContent = 'Copy';
        actions.appendChild(copyBtn);
        wrapper.appendChild(actions);
        const pre = document.createElement('pre');
        pre.className = 'mermaid-source-pre';
        const codeEl = document.createElement('code');
        codeEl.className = 'language-mermaid';
        codeEl.textContent = src.replace(/\s+$/,'');
        pre.appendChild(codeEl);
        wrapper.appendChild(pre);
        details.appendChild(wrapper);
        composite.appendChild(details);
      });
    }

    function renderAll(){
      if (!window.mermaid) return;
      try {
        // Add loading class to unrendered diagrams
        document.querySelectorAll('.mermaid').forEach(el => {
          if (!el.classList.contains('rendered')) {
            el.classList.add('mermaid-loading');
          }
        });
        if (typeof mermaid.run === 'function') {
          mermaid.run({ querySelector: '.mermaid' }).then(()=>{
            // Remove loading class once SVG injected
            document.querySelectorAll('.mermaid').forEach(el => {
              el.classList.remove('mermaid-loading');
              el.classList.add('rendered');
            });
            ensureSourcePanels();
            ensureLegends();
          }).catch(e=>{
            console.warn('Mermaid run() failed:', e);
          });
        }
      } catch(e) {
        console.warn('Mermaid rendering error:', e);
      }
    }

    function fullRender(){
      convertRawCodeBlocks();
      convertAttrBlocks();
      initMermaid();
      renderAll();
    }

    // Auto legend support: if source contains '%% legend:auto', we parse classDef and class usages
    function ensureLegends(){
      document.querySelectorAll('.mermaid.rendered').forEach(diagram => {
        if (diagram.nextElementSibling && diagram.nextElementSibling.classList && diagram.nextElementSibling.classList.contains('mermaid-legend')) return;
        const src = diagram.getAttribute('data-mermaid-source') || '';
        if (!/%%\s*legend:auto/i.test(src)) return;
        // Collect classDefs lines
        const classDefRegex = /classDef\s+(\w+)\s+([^;]+);?/g;
        const defs = {}; let m;
        while ((m = classDefRegex.exec(src)) !== null){
          defs[m[1]] = m[2].trim();
        }
        if (Object.keys(defs).length === 0) return;
        // Create legend container
        const wrapper = document.createElement('div');
        wrapper.className = 'mermaid-legend mt-2 mb-3';
        const title = document.createElement('div');
        title.className = 'mermaid-legend-title fw-semibold small';
        title.textContent = 'Legend';
        wrapper.appendChild(title);
        const list = document.createElement('ul');
        list.className = 'mermaid-legend-list list-unstyled small';
        Object.entries(defs).forEach(([name, def]) => {
          const li = document.createElement('li');
          li.className = 'mermaid-legend-item d-flex align-items-start gap-2';
          // Swatch
            const sw = document.createElement('span');
            sw.className = 'mermaid-legend-swatch';
            sw.setAttribute('data-class', name);
            li.appendChild(sw);
          const text = document.createElement('span');
          text.innerHTML = `<code>${name}</code>`;
          li.appendChild(text);
          list.appendChild(li);
        });
        wrapper.appendChild(list);
        diagram.parentNode.insertBefore(wrapper, diagram.nextSibling);
        // Style swatches after SVG is present by sampling fill/stroke from first node of that class if possible
        try {
          const svg = diagram.querySelector('svg');
          if (svg) {
            wrapper.querySelectorAll('.mermaid-legend-swatch').forEach(sw => {
              const cls = sw.getAttribute('data-class');
              const node = svg.querySelector(`.node.${cls} rect, .node.${cls} path`);
              const fill = node ? window.getComputedStyle(node).fill : '#ccc';
              const stroke = node ? window.getComputedStyle(node).stroke : '#666';
              sw.style.display = 'inline-block';
              sw.style.width = '1.1em';
              sw.style.height = '1.1em';
              sw.style.borderRadius = '0.2em';
              sw.style.border = `1px solid ${stroke || '#666'}`;
              sw.style.background = fill || '#ccc';
              sw.style.marginTop = '0.15em';
            });
          }
        } catch(e) { /* swallow */ }
      });
    }

    // Re-render when theme changes (observe attribute mutations on <html>)
    function installThemeObserver(){
      const htmlEl = document.documentElement;
      let debounceTimer = null;
      const DEBOUNCE_MS = 120; // adjust if needed
      const obs = new MutationObserver(muts => {
        const themeChanged = muts.some(m => m.type==='attributes' && m.attributeName==='data-bs-theme');
        if (!themeChanged) return;
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(()=>{
          initMermaid();
          // Clear existing rendered state so re-run occurs cleanly
          document.querySelectorAll('.mermaid.rendered').forEach(el => {
            el.classList.remove('rendered');
          });
          renderAll();
        }, DEBOUNCE_MS);
      });
      obs.observe(htmlEl, { attributes:true, attributeFilter:['data-bs-theme'] });
    }

    document.addEventListener('DOMContentLoaded', function(){
      if (!haveAnyDiagrams()) return; // nothing to do
      ensureScript(function(){
        fullRender();
        installThemeObserver();
        // Global copy handler (event delegation)
        document.addEventListener('click', function(e){
          const btn = e.target.closest('.mermaid-copy-btn');
            if (!btn) return;
            const details = btn.closest('.mermaid-source-panel');
            if (!details) return;
            const code = details.querySelector('code');
            if (!code) return;
            const text = code.textContent;
            navigator.clipboard.writeText(text).then(()=>{
              const original = btn.textContent;
              btn.textContent = 'Copied!';
              btn.disabled = true;
              setTimeout(()=>{ btn.textContent = original; btn.disabled = false; }, 1600);
            }).catch(()=>{
              btn.textContent = 'Failed';
              setTimeout(()=>{ btn.textContent = 'Copy'; }, 1600);
            });
        });
      });
    });
  })();
</script>
<style>
  /* Lightweight skeleton / placeholder for mermaid while rendering */
  .mermaid.mermaid-loading {
    position: relative;
    min-height: 3.5rem; /* ensures some space before SVG inject */
    color: transparent; /* hide raw text while loading */
  }
  .mermaid.mermaid-loading::after {
    content: 'Rendering diagram…';
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.85rem;
    letter-spacing: .05em;
    color: var(--bs-secondary-color, #666);
    background: linear-gradient(90deg, rgba(255,255,255,0.04), rgba(255,255,255,0.08), rgba(255,255,255,0.04));
    background-size: 200% 100%;
    animation: mermaidShimmer 1.2s linear infinite;
    border: 1px solid rgba(128,128,128,0.15);
    border-radius: 0.35rem;
  }
  @keyframes mermaidShimmer {
    0% { background-position: 0% 0; }
    100% { background-position: -200% 0; }
  }

  /* Source panel styles */
  .mermaid-source-panel {
    margin: 0.35rem 0 1.25rem 0;
    border: 1px solid var(--bs-border-color-translucent, rgba(128,128,128,0.25));
    border-radius: 0.4rem;
    background: var(--bs-tertiary-bg, rgba(0,0,0,0.02));
    font-size: 0.85rem;
  }
  /* Composite wrapper groups diagram + source; provides unified border */
  .mermaid-composite {
    --mermaid-border-color: var(--bs-border-color-translucent, rgba(128,128,128,0.25));
    --mermaid-bg: var(--bs-body-bg, #fff);
    border: 1px solid var(--mermaid-border-color);
    border-radius: 0.55rem;
    background: var(--mermaid-bg);
    padding: 0.75rem 0.75rem 0.35rem;
    margin: 0 0 1.4rem 0;
    box-shadow: 0 1px 2px rgba(0,0,0,0.04);
  }
  .mermaid-composite .mermaid { margin: 0 0 0.25rem; }
  .mermaid-composite .mermaid svg { max-width: 100%; height: auto; }
  /* Remove outer panel border inside composite; rely on composite border */
  .mermaid-composite .mermaid-source-panel {
    margin: 0.25rem 0 0 0;
    border: none;
    border-top: 1px solid var(--mermaid-border-color);
    border-radius: 0;
    background: transparent;
  }
  .mermaid-composite .mermaid-source-panel > summary { padding-left: 0; }
  .mermaid-composite .mermaid-source-wrapper { padding-left: 0; padding-right: 0; }
  .mermaid-composite .mermaid-source-pre { background: var(--bs-tertiary-bg, rgba(0,0,0,0.02)); }
  .mermaid-composite details[open] > summary { background: transparent; }
  .mermaid-source-panel > summary {
    cursor: pointer;
    list-style: none;
    padding: 0.4rem 0.75rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: .35rem;
  }
  .mermaid-source-panel > summary::-webkit-details-marker { display: none; }
  .mermaid-source-panel[open] > summary { border-bottom: 1px solid var(--bs-border-color-translucent, rgba(128,128,128,0.25)); }
  .mermaid-source-wrapper {
    padding: 0.4rem 0.6rem 0.75rem;
    position: relative;
  }
  .mermaid-source-actions {
    display: flex;
    justify-content: flex-end;
    gap: .5rem;
    margin-bottom: .25rem;
  }
  .mermaid-copy-btn {
    font: inherit;
    font-size: 0.7rem;
    padding: 0.25rem .6rem;
    background: var(--bs-secondary-bg, #e0e0e0);
    border: 1px solid var(--bs-border-color, rgba(0,0,0,.15));
    color: var(--bs-body-color, #222);
    border-radius: .35rem;
    cursor: pointer;
    line-height: 1.2;
    transition: background .15s ease, color .15s ease;
  }
  .mermaid-copy-btn:hover:not(:disabled) {
    background: var(--bs-primary, #0d6efd);
    color: #fff;
  }
  .mermaid-copy-btn:disabled { opacity: .6; cursor: default; }
  .mermaid-source-pre {
    margin: 0;
    padding: .6rem .75rem;
    background: var(--bs-body-bg, #fff);
    border: 1px solid var(--bs-border-color-translucent, rgba(128,128,128,0.2));
    border-radius: .35rem;
    overflow-x: auto;
  }
  .mermaid-source-pre code { font-size: 0.75rem; tab-size: 2; }
  @media (max-width: 600px){
    .mermaid-source-pre code { font-size: 0.7rem; }
  }

  /* Semantic node color utility classes (applied via classDef in diagrams) */
  /* These intentionally mirror the palette in buildMermaidConfig for consistency */
  :root[data-bs-theme='light'] .mermaid svg .node.core rect,
  :root[data-bs-theme='light'] .mermaid svg .node.core path { fill: #eef2ff; stroke: #6366f1; }
  :root[data-bs-theme='dark']  .mermaid svg .node.core rect,
  :root[data-bs-theme='dark']  .mermaid svg .node.core path { fill: #312e81; stroke: #818cf8; }

  :root[data-bs-theme='light'] .mermaid svg .node.chat rect,
  :root[data-bs-theme='light'] .mermaid svg .node.chat path { fill: #f0f9ff; stroke: #0ea5e9; }
  :root[data-bs-theme='dark']  .mermaid svg .node.chat rect,
  :root[data-bs-theme='dark']  .mermaid svg .node.chat path { fill: #0c4a6e; stroke: #38bdf8; }

  :root[data-bs-theme='light'] .mermaid svg .node.flow rect,
  :root[data-bs-theme='light'] .mermaid svg .node.flow path { fill: #fff7ed; stroke: #fb923c; }
  :root[data-bs-theme='dark']  .mermaid svg .node.flow rect,
  :root[data-bs-theme='dark']  .mermaid svg .node.flow path { fill: #7c2d12; stroke: #fdba74; }

  :root[data-bs-theme='light'] .mermaid svg .node.agent rect,
  :root[data-bs-theme='light'] .mermaid svg .node.agent path { fill: #f0fdf4; stroke: #22c55e; }
  :root[data-bs-theme='dark']  .mermaid svg .node.agent rect,
  :root[data-bs-theme='dark']  .mermaid svg .node.agent path { fill: #14532d; stroke: #4ade80; }

  :root[data-bs-theme='light'] .mermaid svg .node.note rect,
  :root[data-bs-theme='light'] .mermaid svg .node.note path { fill: #ffffff; stroke-dasharray: 3 3; stroke: #94a3b8; }
  :root[data-bs-theme='dark']  .mermaid svg .node.note rect,
  :root[data-bs-theme='dark']  .mermaid svg .node.note path { fill: #1e293b; stroke-dasharray: 3 3; stroke: #64748b; }

  /* New semantic domain classes */
  :root[data-bs-theme='light'] .mermaid svg .node.tool rect,
  :root[data-bs-theme='light'] .mermaid svg .node.tool path { fill: #9333ea; stroke: #7e22ce; }
  :root[data-bs-theme='dark']  .mermaid svg .node.tool rect,
  :root[data-bs-theme='dark']  .mermaid svg .node.tool path { fill: #c084fc; stroke: #a855f7; }

  :root[data-bs-theme='light'] .mermaid svg .node.memory rect,
  :root[data-bs-theme='light'] .mermaid svg .node.memory path { fill: #db2777; stroke: #be185d; }
  :root[data-bs-theme='dark']  .mermaid svg .node.memory rect,
  :root[data-bs-theme='dark']  .mermaid svg .node.memory path { fill: #f9a8d4; stroke: #f472b6; }

  :root[data-bs-theme='light'] .mermaid svg .node.planner rect,
  :root[data-bs-theme='light'] .mermaid svg .node.planner path { fill: #65a30d; stroke: #4d7c0f; }
  :root[data-bs-theme='dark']  .mermaid svg .node.planner rect,
  :root[data-bs-theme='dark']  .mermaid svg .node.planner path { fill: #bef264; stroke: #84cc16; }

  /* Improve edge contrast */
  :root[data-bs-theme='dark'] .mermaid .edgePath .path { stroke-width: 2px; }
  :root[data-bs-theme='light'] .mermaid .edgePath .path { stroke-width: 2px; }

  /* Accessible focus outline if diagram nodes become tabbable in future */
  .mermaid [tabindex]:focus { outline: 2px solid var(--bs-primary, #0d6efd); outline-offset: 2px; }
  /* Legend styles */
  .mermaid-legend-title { text-transform: uppercase; letter-spacing: .05em; opacity: .85; }
  .mermaid-legend-list { margin: .25rem 0 0; display: grid; grid-template-columns: repeat(auto-fit,minmax(140px,1fr)); gap: .35rem .75rem; }
  .mermaid-legend-item code { font-size: .65rem; }
</style>
