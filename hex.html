<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="apple-touch-icon" href="icon.png">
        <!-- Place favicon.ico in the root directory -->
    </head>
    <body>




    </body>
</html>




<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            body {
                --serif:Cambria,Georgia,serif;--sans-serif:system-ui,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;--monospace:"Roboto Mono","Consolas",monospace,"Segoe UI Symbol","Symbol";--font-size:14px;--line-height:24px;--body-width:450px;font-family: sans-serif;
                font-family: var(--sans-serif);
                font-size: 14px;
                font-size: var(--font-size);
                line-height: 1.5em;
                min-height: 95%
            }

            body.width600 {
                font-size: 16px;
                --font-size:16px;--line-height:calc(1.5 * var(--font-size));--body-width:600px}

            main {
                font-family: var(--serif)
            }

            h1,h2,h3,h4,h5,h6,.sans-serif {
                font-family: var(--sans-serif)
            }

            tt,code,kbd,samp,pre {
                font-family: monospace;
                font-family: var(--monospace);
                font-size: 0.8em;
                font-size-adjust: none
            }

            #table-of-contents {
                background-color: #fff;
                margin-left: 2em;
                padding-left: 2em;
                width: 20em;
                float: right
            }

            #table-of-contents:after {
                clear: both
            }

            #table-of-contents h2 {
                text-shadow: none;
                color: #000;
                background-color: transparent;
                background-image: none;
                padding: 0;
                border-bottom: none;
                border-top: none
            }

            nav,#table-of-contents {
                font-size: calc(var(--font-size) / 1.25)
            }

            header,h2 {
                text-shadow: 0px 2px 5px rgba(0,0,0,0.8);
                text-rendering: optimizeLegibility
            }

            h1 {
                font-size: 2.0em;
                margin: 0;
                line-height: 36px;
                line-height: calc(1.5 * var(--line-height))
            }

            h1 .subheading {
                font-size: 0.5em;
                letter-spacing: normal;
                line-height: 24px;
                line-height: var(--line-height)
            }

            sup,sub {
                position: relative;
                vertical-align: baseline;
                font-size: 0.75em;
                line-height: 0;
                padding-left: 2px
            }

            sup {
                top: -0.5em
            }

            sub {
                bottom: -0.25em
            }

            * {
                box-sizing: border-box
            }

            html,body {
                margin: 0;
                padding: 0
            }

            html {
                background-color: #e4e4e0
            }

            body {
                background-color: #fff;
                color: #333
            }

            main,.comments {
                padding: 0 40px
            }

            header {
                display: block;
                text-align: center;
                padding-top: 24px;
                padding-top: var(--line-height)
            }

            .colored-background {
                color: #fff;
                background-color: #bf4040
            }

            header,footer,.divider,h2 {
                color: #fff;
                background-color: #bf4040
            }

            header a,footer a,.divider a,h2 a {
                color: #f2d9d9
            }

            footer a,.divider a {
                text-decoration: underline
            }

            .comments,.below-divider {
                background-color: #e4e4e0
            }

            .comments {
                padding-bottom: 20px;
                text-shadow: 1px 1px 3px #fff;
                font-size: 0.8em
            }

            h2 {
                margin: 24px auto;
                margin: var(--line-height) auto;
                padding: 11px 40px;
                padding: calc(var(--line-height) / 2 - 1px) 40px;
                font-size: 1.25em;
                max-width: 530px;
                max-width: calc(var(--body-width) + 80px)
            }

            h2 a.anchor {
                float: right;
                width: 2em;
                text-align: right;
                color: #bf4040
            }

            h2:hover a.anchor {
                color: #df9f9f
            }

            h3 {
                margin: 24px 0;
                margin: var(--line-height) 0;
                font-size: 1.125em
            }

            h3 a.anchor {
                float: right;
                width: 2em;
                text-align: right;
                color: #d6c2c2
            }

            h3:hover a.anchor {
                color: #bf4040
            }

            header nav {
                display: block
            }

            header nav ul {
                text-align: center;
                display: -webkit-box;
                display: -ms-flexbox;
                display: flex;
                -webkit-box-orient: horizontal;
                -webkit-box-direction: normal;
                -ms-flex-flow: row wrap;
                flex-flow: row wrap;
                -webkit-box-pack: center;
                -ms-flex-pack: center;
                justify-content: center;
                line-height: 1.0;
                margin: 0
            }

            header nav ul li {
                display: inline-block;
                width: 10%;
                padding: 2px 5px;
                text-align: center;
                -webkit-box-flex: 0;
                -ms-flex: 0 0 4em;
                flex: 0 0 4em;
                -ms-flex-item-align: center;
                -ms-grid-row-align: center;
                align-self: center;
                white-space: nowrap
            }

            header nav ul li a {
                display: block;
                width: 100%;
                font-weight: bold;
                text-decoration: none
            }

            header nav ul li:hover {
                background-color: rgba(0,0,0,0.5);
                font-weight: bold
            }

            section {
                margin: 24px auto;
                margin: var(--line-height) auto;
                max-width: 450px;
                max-width: var(--body-width)
            }

            header,.divider,h2 {
                border-bottom: 1px solid #000
            }

            .divider,h2 {
                border-top: 1px solid #000
            }

            .divider {
                min-height: 48px;
                min-height: calc(2 * var(--line-height));
                text-align: center
            }

            .below-divider {
                padding-top: 24px;
                padding-top: var(--line-height)
            }

            .below-divider>p:first-child {
                font-size: 1.25em;
                text-align: center;
                margin-top: 0
            }

            footer {
                --footer-padding-y:calc(var(--line-height) / 2);--footer-padding-x:var(--font-size);padding: 12px 14px;
                padding: var(--footer-padding-y) var(--footer-padding-x);
                border-top: 1px solid #000
            }

            footer>* {
                margin-left: auto;
                margin-right: auto
            }

            footer>div>address {
                display: block
            }

            footer>div>* {
                text-align: center
            }

            @media (min-width: 50em) {
                footer>div {
                    margin:0 auto;
                    display: -webkit-box;
                    display: -ms-flexbox;
                    display: flex;
                    -webkit-box-orient: horizontal;
                    -webkit-box-direction: normal;
                    -ms-flex-flow: row wrap;
                    flex-flow: row wrap;
                    -webkit-box-pack: center;
                    -ms-flex-pack: center;
                    justify-content: center;
                    max-width: calc(2 * var(--body-width));
                    width: calc(100vw - 2 * var(--footer-padding-x))
                }

                footer>div>address {
                    -webkit-box-flex: 0;
                    -ms-flex: 0 1 20em;
                    flex: 0 1 20em;
                    -ms-flex-item-align: center;
                    -ms-grid-row-align: center;
                    align-self: center;
                    text-align: left
                }

                footer>div>div {
                    -webkit-box-flex: 1;
                    -ms-flex: 1 1 20em;
                    flex: 1 1 20em;
                    -ms-flex-item-align: center;
                    -ms-grid-row-align: center;
                    align-self: center;
                    text-align: right
                }

                footer>div>div>p,footer>div>div>div {
                    margin-top: 0
                }
            }

            h2:target {
                -webkit-animation: target-attention 0.4s 1;
                animation: target-attention 0.4s 1
            }

            @-webkit-keyframes target-attention {
                0% {
                    -webkit-transform: scale(1.1);
                    transform: scale(1.1)
                }

                100% {
                    -webkit-transform: scale(1.1);
                    transform: scale(1.1)
                }
            }

            @keyframes target-attention {
                0% {
                    -webkit-transform: scale(1.1);
                    transform: scale(1.1)
                }

                100% {
                    -webkit-transform: scale(1.1);
                    transform: scale(1.1)
                }
            }

            h2:target {
                font-size: 2.0em
            }

            div:target {
                border: 1px dashed #888
            }

            kbd kbd {
                padding: 1px 7px;
                margin: 0px 1px 3px 1px;
                font-size: 0.75em;
                white-space: nowrap;
                background-color: #ddd;
                color: #242;
                border: 1px solid rgba(0,0,0,0.2);
                border-radius: 3px;
                box-shadow: inset 0 0 1px 1px #fff,0 2px 0 rgba(0,0,0,0.3)
            }

            samp,kbd {
                background-color: #f4f4f0
            }

            code,samp {
                color: #442
            }

            kbd {
                margin: 0 7px;
                color: #252
            }

            section>img {
                max-width: 100%;
                height: auto;
                -ms-interpolation-mode: bicubic
            }

            section figcaption {
                font-size: 0.75em;
                line-height: 1.1;
                text-align: center
            }

            a {
                color: #bf4040;
                text-decoration: none
            }

            a:hover {
                text-decoration: underline
            }

            header,footer,h2,.divider {
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale
            }

            h1,h2,h3,h4,h5,h6 {
                -webkit-font-feature-settings: "liga", "clig", "calt", "onum", "kern";
                font-feature-settings: "liga", "clig", "calt", "onum", "kern";
                -webkit-font-variant-ligatures: common-ligatures contextual;
                font-variant-ligatures: common-ligatures contextual;
                font-variant-numeric: oldstyle-nums
            }

            section p,section li {
                -webkit-font-feature-settings: "liga", "clig", "calt", "onum", "kern";
                font-feature-settings: "liga", "clig", "calt", "onum", "kern";
                -webkit-font-variant-ligatures: normal;
                font-variant-ligatures: normal;
                font-variant-numeric: oldstyle-nums;
                hanging-punctuation: first last;
                text-align: justify;
                -ms-hyphens: auto;
                -webkit-hyphens: auto;
                hyphens: auto
            }

            nav,figure,td,abbr,acronym,code,kbd,samp,tt,var,pre {
                -webkit-font-feature-settings: "liga" off, "clig" off, "kern" off, "tnum" on, "lnum" on;
                font-feature-settings: "liga" off, "clig" off, "kern" off, "tnum" on, "lnum" on;
                -webkit-font-variant-ligatures: none;
                font-variant-ligatures: none;
                font-variant-numeric: lining-nums tabular-nums slashed-zero;
                -ms-hyphens: none;
                -webkit-hyphens: none;
                hyphens: none
            }

            p,figure,ul,ol {
                margin: 24px 0;
                margin: var(--line-height) 0
            }

            ul ul,ul ol,ol ul,ol ol,li ul,li ol {
                margin: 0
            }

            ul,ol {
                margin-left: 0;
                padding-left: 21px;
                padding-left: calc(var(--font-size) * 3/2)
            }

            dt {
                font-weight: bold
            }

            pre {
                max-width: 450px;
                max-width: var(--body-width);
                line-height: 1.4;
                overflow: auto;
                border-top: 1px solid #ccc;
                border-bottom: 1px solid #ccc;
                border-left-width: 0;
                border-right-width: 0
            }

            pre::-webkit-scrollbar {
                height: 1em
            }

            pre::-webkit-scrollbar-thumb:horizontal {
                border-radius: 0.5em;
                background: rgba(0,0,0,0.4)
            }

            pre.simple,.comments pre {
                overflow: auto;
                width: 100%;
                border: none;
                background: transparent;
                background-color: transparent;
                box-shadow: none
            }

            pre.snippet,pre.src {
                border-top-style: dashed;
                border-bottom-style: dashed
            }

            section>pre:only-child {
                padding-bottom: 14px;
                border-bottom: 1px solid rgba(0,0,0,0.5)
            }

            blockquote {
                font-style: italic
            }

            table.standard {
                border: 1px solid rgba(0,0,0,0.5);
                border-collapse: collapse
            }

            table.standard th {
                background-color: #f8f8f8;
                background: linear-gradient(to bottom, #f8f8f8,#f8f8f8,#f0f0f0)
            }

            table.standard td {
                background-color: #fff
            }

            table.standard th,table.standard td {
                border: 1px solid rgba(0,0,0,0.5)
            }

            aside,p.note,div.note>p {
                margin: 1em;
                padding: 1em;
                background: #eee;
                border: 1px solid #ddd;
                box-shadow: 0 8px 6px -6px rgba(0,0,0,0.4)
            }

            svg {
                overflow: hidden
            }

            tt,code {
                padding: 0 2px
            }

            main>address,section>address,section>time {
                display: block;
                max-width: 450px;
                max-width: var(--body-width);
                font-family: var(--sans-serif);
                text-align: right
            }

            main>address {
                margin-left: auto;
                margin-right: auto
            }

            @media (max-width: 700px) {
                body:not(.widthflex) main,body:not(.widthflex) .comments {
                    padding:0 10px
                }

                body:not(.widthflex) pre {
                    font-size: 0.64em
                }
            }

            @media (max-width: 600px) {
                header nav {
                    display:none
                }
            }

            form {
                margin: 0
            }

            input[type="text"] {
                max-width: 100%;
                border: 1px solid rgba(0,0,0,0.7);
                background-color: #f8f8f4;
                color: #000;
                text-align: center;
                font-weight: bold
            }

            input[type="text"]:focus {
                background-color: #fffff4
            }

            input::-webkit-input-placeholder {
                color: #aaa
            }

            input::-moz-placeholder {
                color: #aaa
            }

            input[type="search"][name="q"] {
                box-shadow: inset 0 2px 5px 0 rgba(0,0,0,0.5);
                border-radius: 10px;
                padding: 5px 10px;
                border-width: 0
            }

            body.widthflex {
                --font-size:calc(10px + 1vw);--line-height:calc(1.5 * var(--font-size));--body-width:calc(100vw - 36px)}

            @media (min-width: 550px) {
                body.widthflex {
                    --body-width:calc(330px + 33vw);
                    --font-size:calc(var(--body-width) / 33)}
            }

            @media (min-width: 1000px) {
                body.widthflex {
                    --body-width:660px
                }
            }

            body.widthflex main {
                margin-left: 0;
                margin-right: 0;
                padding-left: 0;
                padding-right: 0
            }

            body.widthflex section {
                max-width: none
            }

            body.widthflex header>*,body.widthflex section>*,body.widthflex .comments {
                margin-left: auto;
                margin-right: auto
            }

            body.widthflex section>*,body.widthflex .comments {
                width: 450px;
                max-width: 660px;
                width: var(--body-width)
            }

            body.widthflex section>h2 {
                max-width: calc(80px + var(--body-width));
                width: 100%
            }

            body.widthflex img {
                max-width: 100%;
                height: auto
            }

            .TODO {
                color: #bf4040;
                background: #e8e3e3;
                border: 1px solid #bf4040;
                margin-left: 0.5ex
            }

            .DONE {
                color: #4040bf;
                background: #e3e3e8;
                border: 1px solid #4040bf
            }

            .src .comment-delimiter,.src .nxml-comment-delimiter {
                color: #4488ff
            }

            .src .comment,.src .nxml-comment-content {
                color: #006699
            }

            .src .keyword {
                color: #406abf;
                font-weight: bold
            }

            .src .builtin {
                color: #508b20
            }

            .src .warning {
                color: #cc0000
            }

            .src .function-name {
                color: #268bd2;
                font-weight: bold
            }

            .src .variable-name {
                color: #00008b
            }

            .src .type {
                color: #6c71c4
            }

            .src .constant-face {
                color: #d33682
            }

            .src .doc {
                color: #666666;
                background-color: #e2e6e8
            }

            .src .string {
                color: #888888
            }

            .src .preprocessor {
                color: #859900
            }

            .src .negation-char,.src .sh-escaped-newline {
                color: #ff0000
            }

            .src .todo {
                color: #ffffff;
                background: #dc322f
            }

            .src .note {
                color: #ffffff;
                background: #2aa198
            }

            .src .hack {
                color: #ffffff;
                background: #859900
            }

            .src .paren {
                color: #a0a090;
                font-weight: bold
            }

            .src .minor-control-construct {
                color: #268bd2
            }

            .src .major-control-construct {
                color: #bf4040
            }

            .src-cpp .constant {
                color: #999999
            }

            .src-emacs-lisp .paren {
                color: #c9c9c4
            }

            .src-sh .string,.src-sh .comment {
                color: inherit
            }

            .src-python .highlight-indentation {
                border-right: 2px solid #eeeeee
            }

            .src-xml .nxml-element-local-name {
                color: #406abf;
                font-weight: normal
            }

            .src-xml .nxml-tag-delimiter,.src-xml .nxml-tag-slash {
                color: #9cabc9;
                font-weight: bold
            }

            table.standard td.left,table.standard th.left {
                text-align: left
            }

            table.standard td.center,table.standard th.center {
                text-align: center
            }

            table.standard td.right,table.standard th.right {
                text-align: right
            }

            *[class^="section-number"] {
                color: #966
            }

            h2 *[class^="section-number"] {
                color: #e6b3b3;
                text-align: right;
                display: inline-block;
                margin-left: -40px;
                width: 40px
            }

            h3 *[class^="section-number"] {
                color: #e6b3b3;
                background-color: #bf4040;
                border-top: 1px solid black;
                border-bottom: 1px solid black;
                text-shadow: 0px 2px 5px rgba(0,0,0,0.8);
                text-rendering: optimizeLegibility;
                text-align: center;
                display: inline-block;
                padding: 4px 0;
                width: 40px;
                margin-left: -44px
            }

            @media only screen and (max-width: 700px) {
                h3 *[class^="section-number"] {
                    margin-left:-10px
                }
            }

            @media print {
                body {
                    --font-size:12pt;--serif:"Book Antiqua", "Times New Roman", serif;--sans-serif:"Helvetica", sans-serif;--monospace:"Courier", "Courier New", monospace}

                a {
                    text-decoration: underline
                }

                header,footer,.divider,h2 {
                    text-shadow: none;
                    color: #000;
                    background-image: none;
                    background-color: none
                }

                nav,.comments {
                    display: none
                }
            }

            header,footer,.divider,h2 {
                background-image: url("/img/transparent-blob.png"),url("/img/transparent-blob.png");
                background-position: 0 0, 16px 16px
            }
        </style>
    </head>
    <body class="gameprog widthflex">
        <main>
            <div id="table-of-contents">
                <h2>Table of Contents</h2>
                <div id="text-table-of-contents">
                    <ul>
                        <li>
                            <a href="#layout">2. Layout</a>
                            <ul>
                                <li>
                                    <a href="#layout-examples">2.4. Layout examples</a>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <a href="#fractionalhex">3. Fractional Hex</a>
                            <ul>
                                <li>
                                    <a href="#rounding">3.1. Hex rounding</a>
                                </li>
                                <li>
                                    <a href="#line-drawing">3.2. Line drawing</a>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <a href="#map">4. Map</a>
                            <ul>
                                <li>
                                    <a href="#map-storage">4.1. Map storage</a>
                                </li>
                                <li>
                                    <a href="#map-shapes">4.2. Map shapes</a>
                                </li>
                                <li>
                                    <a href="#map-optimized-storage">4.3. Optimized storage</a>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <a href="#rotation">5. Rotation</a>
                        </li>
                        <li>
                            <a href="#offset">6. Offset coordinates</a>
                        </li>
                        <li>
                            <a href="#notes">7. Notes</a>
                            <ul>
                                <li>
                                    <a href="#cube-vs-axial">7.1. Cube vs Axial</a>
                                </li>
                                <li>
                                    <a href="#cpp">7.2. C++</a>
                                </li>
                                <li>
                                    <a href="#dynamic-typing">7.3. Python, Javascript</a>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <a href="#code">8. Source Code</a>
                            <ul>
                                <li>
                                    <a href="#codegen">8.1. Code from this page</a>
                                </li>
                                <li>
                                    <a href="#third-party">8.2. Other libraries</a>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
            <section>
                <div id="outline-container-orgc0ea144" class="outline-3">
                    <h3 id="layout-examples">
                        <a id="orgc0ea144"></a>
                        <span class="section-number-3">2.4</span>
                        Layout examples<a class="anchor" href="#layout-examples">#</a>
                    </h3>
                    <div class="outline-text-3" id="text-layout-examples">
                       <canvas id="layout-test-orientation-pointy" width="1200" height="1200"></canvas></br>




                        <canvas id="layout-test-orientation-flat" width="300" height="200"></canvas>
                        <p>
                            Let &#8217;s try three different sizes, <code>Point(10, 10)</code>
                            , <code>Point(20, 20)</code>
                            , and <code>Point(40, 40)</code>
                            :
                        </p>
                        <canvas id="layout-test-size-1" width="200" height="200"></canvas>
                        <canvas id="layout-test-size-2" width="200" height="200"></canvas>
                        <canvas id="layout-test-size-3" width="200" height="200"></canvas>
                        <p>
                            Let &#8217;s try stretching the hexes, by setting size to <code>Point(15, 25)</code>
                            and <code>Point(25, 15)</code>
                            :
                        </p>
                        <canvas id="layout-test-size-tall" width="300" height="200"></canvas>
                        <canvas id="layout-test-size-wide" width="300" height="200"></canvas>
                        <p>
                            Let &#8217;s try a downward y-axis with size set to <code>Point(25, 25)</code>
                            and a flipped (upward) y-axis with size set to <code>Point(25, -25)</code>
                            . Look closely at how <code>r</code>
                            increases downwards vs upwards:
                        </p>
                        <canvas id="layout-test-y-down" width="300" height="200"></canvas>
                        <canvas id="layout-test-y-up" width="300" height="200"></canvas>
                        <p>I think that &#8217;s a reasonable set of tests for the orientation and size, and it shows that the Layout class can handle a wide variety of needs, without having to make different variants of the Hex class.</p>
                    </div>
                </div>
            </section>
            <section>
                <h2 id="fractionalhex">
                    <a class="anchor" href="#fractionalhex">#</a>
                    <span class="section-number">3  </span>
                    Fractional Hex
                </h2>
                <div class="outline-text-2" id="text-fractionalhex">
                    <p>
                        For pixel-to-hex I need fractional hex coordinates. It looks like the <b>Hex</b>
                        class, but uses <code>double</code>
                        instead of <code>int</code>
                        :
                    </p>
                    <div class="org-src-container">
                        <pre class="src src-cpp">
                            <span class="keyword">struct</span>
                            <span class="type">FractionalHex</span>
                            <span class="minor-control-construct">
                                <span class="paren">{</span>
                            </span>
                            <span class="keyword">const</span>
                            <span class="type">double</span>
                            <span class="variable-name">q</span>
                            , <span class="variable-name">r</span>
                            , <span class="variable-name">s</span>
                            ;
    <span class="function-name">FractionalHex</span>
                            <span class="paren">(</span>
                            <span class="type">double</span>
                            <span class="variable-name">q_</span>
                            , <span class="type">double</span>
                            <span class="variable-name">r_</span>
                            , <span class="type">double</span>
                            <span class="variable-name">s_</span>
                            <span class="paren">)</span>
                            : q<span class="paren">(</span>
                            q_<span class="paren">)</span>
                            , r<span class="paren">(</span>
                            r_<span class="paren">)</span>
                            , s<span class="paren">(</span>
                            s_<span class="paren">)</span>
                            <span class="minor-control-construct">
                                <span class="paren">{}</span>
                            </span>
                            <span class="minor-control-construct">
                                <span class="paren">}</span>
                            </span>
                            ;

                        </pre>
                    </div>
                </div>
                <div id="outline-container-orga3f746e" class="outline-3">
                    <h3 id="rounding">
                        <a id="orga3f746e"></a>
                        <span class="section-number-3">3.1</span>
                        Hex rounding<a class="anchor" href="#rounding">#</a>
                    </h3>
                    <div class="outline-text-3" id="text-rounding">
                        <p>
                            Rounding turns a fractional hex coordinate into the nearest integer hex coordinate. The algorithm is straight out of the <a href="./#rounding">main article</a>
                            :
                        </p>
                        <div class="org-src-container">
                            <pre class="src src-cpp">
                                <span class="type">Hex</span>
                                <span class="function-name">hex_round</span>
                                <span class="paren">(</span>
                                <span class="type">FractionalHex</span>
                                <span class="variable-name">h</span>
                                <span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="type">int</span>
                                <span class="variable-name">q</span>
                                = <span class="type">int</span>
                                <span class="paren">(</span>
                                round<span class="paren">(</span>
                                h.q<span class="paren">))</span>
                                ;
    <span class="type">int</span>
                                <span class="variable-name">r</span>
                                = <span class="type">int</span>
                                <span class="paren">(</span>
                                round<span class="paren">(</span>
                                h.r<span class="paren">))</span>
                                ;
    <span class="type">int</span>
                                <span class="variable-name">s</span>
                                = <span class="type">int</span>
                                <span class="paren">(</span>
                                round<span class="paren">(</span>
                                h.s<span class="paren">))</span>
                                ;
    <span class="type">double</span>
                                <span class="variable-name">q_diff</span>
                                = abs<span class="paren">(</span>
                                q - h.q<span class="paren">)</span>
                                ;
    <span class="type">double</span>
                                <span class="variable-name">r_diff</span>
                                = abs<span class="paren">(</span>
                                r - h.r<span class="paren">)</span>
                                ;
    <span class="type">double</span>
                                <span class="variable-name">s_diff</span>
                                = abs<span class="paren">(</span>
                                s - h.s<span class="paren">)</span>
                                ;
    <span class="keyword">if</span>
                                <span class="paren">(</span>
                                q_diff &gt;r_diff <span class="keyword">and</span>
                                q_diff &gt;s_diff<span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                q = -r - s;
    
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                <span class="keyword">else</span>
                                <span class="keyword">if</span>
                                <span class="paren">(</span>
                                r_diff &gt;s_diff<span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                r = -q - s;
    
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                <span class="keyword">else</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                s = -q - r;
    
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                <span class="major-control-construct">return</span>
                                Hex<span class="paren">(</span>
                                q, r, s<span class="paren">)</span>
                                ;

                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                            </pre>
                        </div>
                    </div>
                </div>
                <div id="outline-container-org6e89814" class="outline-3">
                    <h3 id="line-drawing">
                        <a id="org6e89814"></a>
                        <span class="section-number-3">3.2</span>
                        Line drawing<a class="anchor" href="#line-drawing">#</a>
                    </h3>
                    <div class="outline-text-3" id="text-line-drawing">
                        <p>
                            To draw a line, I linearly interpolate between two hexes, and then round it to the nearest hex. To linearly interpolate between hex coordinates I linearly interpolate each of the components (<code>q</code>
                            , <code>r</code>
                            , <code>s</code>
                            ) independently:
                        </p>
                        <div class="org-src-container">
                            <pre class="src src-cpp">
                                <span class="type">float</span>
                                <span class="function-name">lerp</span>
                                <span class="paren">(</span>
                                <span class="type">double</span>
                                <span class="variable-name">a</span>
                                , <span class="type">double</span>
                                <span class="variable-name">b</span>
                                , <span class="type">double</span>
                                <span class="variable-name">t</span>
                                <span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="major-control-construct">return</span>
                                a * <span class="paren">(</span>
                                <span class="constant">1</span>
                                -t<span class="paren">)</span>
                                + b * t;
    <span class="comment-delimiter">/* </span>
                                <span class="comment">better for floating point precision than</span>
                                <span class="comment">a + </span>
                                <span class="comment">
                                    <span class="paren">(</span>
                                </span>
                                <span class="comment">b - a</span>
                                <span class="comment">
                                    <span class="paren">)</span>
                                </span>
                                <span class="comment">* t, which is what I usually write */</span>
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                <span class="type">FractionalHex</span>
                                <span class="function-name">hex_lerp</span>
                                <span class="paren">(</span>
                                <span class="type">Hex</span>
                                <span class="variable-name">a</span>
                                , <span class="type">Hex</span>
                                <span class="variable-name">b</span>
                                , <span class="type">double</span>
                                <span class="variable-name">t</span>
                                <span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="major-control-construct">return</span>
                                FractionalHex<span class="paren">(</span>
                                lerp<span class="paren">(</span>
                                a.q, b.q, t<span class="paren">)</span>
                                ,
                         lerp<span class="paren">(</span>
                                a.r, b.r, t<span class="paren">)</span>
                                ,
                         lerp<span class="paren">(</span>
                                a.s, b.s, t<span class="paren">))</span>
                                ;

                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                            </pre>
                        </div>
                        <p>Line drawing is not too bad once I have linear interpolation:</p>
                        <div class="org-src-container">
                            <pre class="src src-cpp">
                                <span class="type">vector</span>
                                &lt;Hex &gt;<span class="function-name">hex_linedraw</span>
                                <span class="paren">(</span>
                                <span class="type">Hex</span>
                                <span class="variable-name">a</span>
                                , <span class="type">Hex</span>
                                <span class="variable-name">b</span>
                                <span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="type">int</span>
                                <span class="variable-name">N</span>
                                = hex_distance<span class="paren">(</span>
                                a, b<span class="paren">)</span>
                                ;
    <span class="type">vector</span>
                                &lt;<span class="type">Hex</span>
                                &gt;<span class="variable-name">results</span>
                                = 
                                <span class="minor-control-construct">
                                    <span class="paren">{}</span>
                                </span>
                                ;
    <span class="type">double</span>
                                <span class="variable-name">step</span>
                                = <span class="constant">1.0</span>
                                / max<span class="paren">(</span>
                                N, <span class="constant">1</span>
                                <span class="paren">)</span>
                                ;
    <span class="keyword">for</span>
                                <span class="paren">(</span>
                                <span class="type">int</span>
                                <span class="variable-name">i</span>
                                = <span class="constant">0</span>
                                ; i &lt;= N; i++<span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                results.push_back<span class="paren">(</span>
                                hex_round<span class="paren">(</span>
                                hex_lerp<span class="paren">(</span>
                                a, b, step * i<span class="paren">)))</span>
                                ;
    
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                <span class="major-control-construct">return</span>
                                results;

                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                            </pre>
                        </div>
                        <p>
                            I needed to stick that <code>max(N, 1)</code>
                            bit in there to handle lines with length 0 (when A == B).
                        </p>
                        <p>
                            Sometimes the <code>hex_lerp</code>
                            will output a point that &#8217;s <i>on an edge</i>
                            . On some systems, the rounding code will push that to one side or the other, somewhat unpredictably and inconsistently. To make it always push these points in the same direction, add an “epsilon” value to <code>a</code>
                            . This will “nudge” things in the same direction when it &#8217;s on an edge, and leave other points unaffected.
                        </p>
                        <div class="org-src-container">
                            <pre class="src src-cpp">
                                <span class="type">vector</span>
                                &lt;Hex &gt;<span class="function-name">hex_linedraw</span>
                                <span class="paren">(</span>
                                <span class="type">Hex</span>
                                <span class="variable-name">a</span>
                                , <span class="type">Hex</span>
                                <span class="variable-name">b</span>
                                <span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="type">int</span>
                                <span class="variable-name">N</span>
                                = hex_distance<span class="paren">(</span>
                                a, b<span class="paren">)</span>
                                ;
    <span class="type">FractionalHex</span>
                                <span class="variable-name">a_nudge</span>
                                <span class="paren">(</span>
                                a.q + 1e-<span class="constant">6</span>
                                , a.r + 1e-<span class="constant">6</span>
                                , a.s - 2e-<span class="constant">6</span>
                                <span class="paren">)</span>
                                ;
    <span class="type">FractionalHex</span>
                                <span class="variable-name">b_nudge</span>
                                <span class="paren">(</span>
                                b.q + 1e-<span class="constant">6</span>
                                , b.r + 1e-<span class="constant">6</span>
                                , b.s - 2e-<span class="constant">6</span>
                                <span class="paren">)</span>
                                ;
    <span class="type">vector</span>
                                &lt;<span class="type">Hex</span>
                                &gt;<span class="variable-name">results</span>
                                = 
                                <span class="minor-control-construct">
                                    <span class="paren">{}</span>
                                </span>
                                ;
    <span class="type">double</span>
                                <span class="variable-name">step</span>
                                = <span class="constant">1.0</span>
                                / max<span class="paren">(</span>
                                N, <span class="constant">1</span>
                                <span class="paren">)</span>
                                ;
    <span class="keyword">for</span>
                                <span class="paren">(</span>
                                <span class="type">int</span>
                                <span class="variable-name">i</span>
                                = <span class="constant">0</span>
                                ; i &lt;= N; i++<span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                results.push_back<span class="paren">(</span>
                                hex_round<span class="paren">(</span>
                                hex_lerp<span class="paren">(</span>
                                a_nudge, b_nudge, step * i<span class="paren">)))</span>
                                ;
    
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                <span class="major-control-construct">return</span>
                                results;

                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                            </pre>
                        </div>
                        <p>The nudge is not always needed. You might try without it first.</p>
                    </div>
                </div>
            </section>
            <section>
                <h2 id="map">
                    <a class="anchor" href="#map">#</a>
                    <span class="section-number">4  </span>
                    Map
                </h2>
                <div class="outline-text-2" id="text-map">
                    <p>
                        There are <i>two</i>
                        related problems to solve: how to <b>generate a shape</b>
                        and how to <b>store map data</b>
                        . Let &#8217;s start with storing map data.
                    </p>
                </div>
                <div id="outline-container-org0bb203b" class="outline-3">
                    <h3 id="map-storage">
                        <a id="org0bb203b"></a>
                        <span class="section-number-3">4.1</span>
                        Map storage<a class="anchor" href="#map-storage">#</a>
                    </h3>
                    <div class="outline-text-3" id="text-map-storage">
                        <p>
                            The simplest way to store a map is to use a hash table. In C++, in order to use <code>unordered_map &lt;Hex,_ &gt;</code>
                            or <code>unordered_set &lt;Hex &gt;</code>
                            I need to define a hash function for <code>Hex</code>
                            . It would &#8217;ve been nice if C++ made it easier to define this, but it &#8217;s not too bad. I hash the <code>q</code>
                            and <code>r</code>
                            fields (I can skip <code>s</code>
                            because it &#8217;s redundant), and combine them using the algorithm from Boost &#8217;s <code>hash_combine</code>
                            :
                        </p>
                        <div class="org-src-container">
                            <pre class="src src-cpp">
                                <span class="keyword">namespace</span>
                                <span class="constant">std</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="keyword">template</span>
                                &lt;&gt;<span class="keyword">struct</span>
                                <span class="type">hash</span>
                                &lt;Hex &gt;
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="type">size_t</span>
                                <span class="keyword">operator</span>
                                <span class="paren">()(</span>
                                <span class="keyword">const</span>
                                <span class="type">Hex</span>
                                &amp;<span class="variable-name">h</span>
                                <span class="paren">)</span>
                                <span class="keyword">const</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="type">hash</span>
                                &lt;<span class="type">int</span>
                                &gt;<span class="variable-name">int_hash</span>
                                ;
            <span class="type">size_t</span>
                                <span class="variable-name">hq</span>
                                = int_hash<span class="paren">(</span>
                                h.q<span class="paren">)</span>
                                ;
            <span class="type">size_t</span>
                                <span class="variable-name">hr</span>
                                = int_hash<span class="paren">(</span>
                                h.r<span class="paren">)</span>
                                ;
            <span class="major-control-construct">return</span>
                                hq ^ <span class="paren">(</span>
                                hr + 0x9e3779b9 + <span class="paren">(</span>
                                hq &lt;&lt;<span class="constant">6</span>
                                <span class="paren">)</span>
                                + <span class="paren">(</span>
                                hq &gt;&gt;<span class="constant">2</span>
                                <span class="paren">))</span>
                                ;
        
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                ;

                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                            </pre>
                        </div>
                        <p>
                            Here &#8217;s an example of making a map with a <code>float</code>
                            height at each hex:
                        </p>
                        <div class="org-src-container">
                            <pre class="src src-cpp">
                                <span class="type">unordered_map</span>
                                &lt;Hex, <span class="type">float</span>
                                &gt;<span class="variable-name">heights</span>
                                ;
heights<span class="paren">[</span>
                                Hex<span class="paren">(</span>
                                <span class="constant">1</span>
                                , -<span class="constant">2</span>
                                , <span class="constant">3</span>
                                <span class="paren">)]</span>
                                = <span class="constant">4.3</span>
                                ;
cout &lt;&lt;heights<span class="paren">[</span>
                                Hex<span class="paren">(</span>
                                <span class="constant">1</span>
                                , -<span class="constant">2</span>
                                , <span class="constant">3</span>
                                <span class="paren">)]</span>
                                ;

                            </pre>
                        </div>
                        <p>The hash table by itself isn &#8217;t that useful. I need to combine it with something that creates a map shape. In graph terms, I need something that creates the nodes.</p>
                    </div>
                </div>
                <div id="outline-container-orgdd59c10" class="outline-3">
                    <h3 id="map-shapes">
                        <a id="orgdd59c10"></a>
                        <span class="section-number-3">4.2</span>
                        Map shapes<a class="anchor" href="#map-shapes">#</a>
                    </h3>
                    <div class="outline-text-3" id="text-map-shapes">
                        <p>In this section I write some loops that will produce various shapes of maps. You can use these loops to make a set of hex coordinates for your map, or fill in a map data structure, or iterate over the locations in the map. I &#8217;ll write sample code that fills in a set of hex coordinates.</p>
                    </div>
                    <div id="outline-container-orgeedba6a" class="outline-4">
                        <h4 id="orgeedba6a">
                            <span class="section-number-4">4.2.1</span>
                            Parallelograms
                        </h4>
                        <div class="outline-text-4" id="text-4-2-1">
                            <p>With axial/cube coordinates, a straightforward loop over coordinates will produce a parallelogram map instead of a rectangular one.</p>
                            <div class="org-src-container">
                                <pre class="src src-cpp">
                                    <span class="type">unordered_set</span>
                                    &lt;Hex &gt;<span class="variable-name">map</span>
                                    ;
<span class="keyword">for</span>
                                    <span class="paren">(</span>
                                    <span class="type">int</span>
                                    <span class="variable-name">q</span>
                                    = q1; q &lt;= q2; q++<span class="paren">)</span>
                                    <span class="minor-control-construct">
                                        <span class="paren">{</span>
                                    </span>
                                    <span class="keyword">for</span>
                                    <span class="paren">(</span>
                                    <span class="type">int</span>
                                    <span class="variable-name">r</span>
                                    = r1; r &lt;= r2; r++<span class="paren">)</span>
                                    <span class="minor-control-construct">
                                        <span class="paren">{</span>
                                    </span>
                                    map.insert<span class="paren">(</span>
                                    Hex<span class="paren">(</span>
                                    q, r, -q-r<span class="paren">)))</span>
                                    ;
    
                                    <span class="minor-control-construct">
                                        <span class="paren">}</span>
                                    </span>
                                    <span class="minor-control-construct">
                                        <span class="paren">}</span>
                                    </span>
                                </pre>
                            </div>
                            <p>There are three coordinates, and the loop requires you choose any two of them: (q,r), (s,q), or (r,s) lead to these pointy top maps, respectively:</p>
                            <canvas id="shape-pointy-parallelogram-qr" width="200" height="200"></canvas>
                            <canvas id="shape-pointy-parallelogram-sq" width="200" height="200"></canvas>
                            <canvas id="shape-pointy-parallelogram-rs" width="200" height="200"></canvas>
                            <p>And these flat top maps:</p>
                            <canvas id="shape-flat-parallelogram-qr" width="200" height="200"></canvas>
                            <canvas id="shape-flat-parallelogram-sq" width="200" height="200"></canvas>
                            <canvas id="shape-flat-parallelogram-rs" width="200" height="200"></canvas>
                        </div>
                    </div>
                    <div id="outline-container-orgea7d157" class="outline-4">
                        <h4 id="orgea7d157">
                            <span class="section-number-4">4.2.2</span>
                            Triangles
                        </h4>
                        <div class="outline-text-4" id="text-4-2-2">
                            <p>There are two directions for triangles to face, and the loop depends on which direction you use. Assuming the y axis points down, with pointy top these triangles face south/northwest/northeast, and with flat top these triangles face east/northwest/southwest.</p>
                            <div class="org-src-container">
                                <pre class="src src-cpp">
                                    <span class="type">unordered_set</span>
                                    &lt;Hex &gt;<span class="variable-name">map</span>
                                    ;
<span class="keyword">for</span>
                                    <span class="paren">(</span>
                                    <span class="type">int</span>
                                    <span class="variable-name">q</span>
                                    = <span class="constant">0</span>
                                    ; q &lt;= map_size; q++<span class="paren">)</span>
                                    <span class="minor-control-construct">
                                        <span class="paren">{</span>
                                    </span>
                                    <span class="keyword">for</span>
                                    <span class="paren">(</span>
                                    <span class="type">int</span>
                                    <span class="variable-name">r</span>
                                    = <span class="constant">0</span>
                                    ; r &lt;= map_size - q; r++<span class="paren">)</span>
                                    <span class="minor-control-construct">
                                        <span class="paren">{</span>
                                    </span>
                                    map.insert<span class="paren">(</span>
                                    Hex<span class="paren">(</span>
                                    q, r, -q-r<span class="paren">))</span>
                                    ;
    
                                    <span class="minor-control-construct">
                                        <span class="paren">}</span>
                                    </span>
                                    <span class="minor-control-construct">
                                        <span class="paren">}</span>
                                    </span>
                                </pre>
                            </div>
                            <canvas id="shape-pointy-triangle-1" width="300" height="200"></canvas>
                            <canvas id="shape-pointy-triangle-2" width="300" height="200"></canvas>
                            <p>With pointy top these triangles face north/southwest/southeast and with flat top these triangles face west/northeast/southeast:</p>
                            <div class="org-src-container">
                                <pre class="src src-cpp">
                                    <span class="type">unordered_set</span>
                                    &lt;Hex &gt;<span class="variable-name">map</span>
                                    ;
<span class="keyword">for</span>
                                    <span class="paren">(</span>
                                    <span class="type">int</span>
                                    <span class="variable-name">q</span>
                                    = <span class="constant">0</span>
                                    ; q &lt;= map_size; q++<span class="paren">)</span>
                                    <span class="minor-control-construct">
                                        <span class="paren">{</span>
                                    </span>
                                    <span class="keyword">for</span>
                                    <span class="paren">(</span>
                                    <span class="type">int</span>
                                    <span class="variable-name">r</span>
                                    = map_size - q; r &lt;= map_size; r++<span class="paren">)</span>
                                    <span class="minor-control-construct">
                                        <span class="paren">{</span>
                                    </span>
                                    map.insert<span class="paren">(</span>
                                    Hex<span class="paren">(</span>
                                    q, r, -q-r<span class="paren">))</span>
                                    ;
    
                                    <span class="minor-control-construct">
                                        <span class="paren">}</span>
                                    </span>
                                    <span class="minor-control-construct">
                                        <span class="paren">}</span>
                                    </span>
                                </pre>
                            </div>
                            <canvas id="shape-flat-triangle-1" width="300" height="200"></canvas>
                            <canvas id="shape-flat-triangle-2" width="300" height="200"></canvas>
                            <p>If your flip your y-axis, then it &#8217;ll switch north and south here, as you might expect.</p>
                        </div>
                    </div>
                    <div id="outline-container-org685eb4e" class="outline-4">
                        <h4 id="org685eb4e">
                            <span class="section-number-4">4.2.3</span>
                            Hexagons
                        </h4>
                        <div class="outline-text-4" id="text-4-2-3">
                            <p>
                                Generating a hexagonal shape map is described <a href="./#range">on the main page</a>
                                .
                            </p>
                            <div class="org-src-container">
                                <pre class="src src-cpp">
                                    <span class="type">unordered_set</span>
                                    &lt;Hex &gt;<span class="variable-name">map</span>
                                    ;
<span class="keyword">for</span>
                                    <span class="paren">(</span>
                                    <span class="type">int</span>
                                    <span class="variable-name">q</span>
                                    = -map_radius; q &lt;= map_radius; q++<span class="paren">)</span>
                                    <span class="minor-control-construct">
                                        <span class="paren">{</span>
                                    </span>
                                    <span class="type">int</span>
                                    <span class="variable-name">r1</span>
                                    = max<span class="paren">(</span>
                                    -map_radius, -q - map_radius<span class="paren">)</span>
                                    ;
    <span class="type">int</span>
                                    <span class="variable-name">r2</span>
                                    = min<span class="paren">(</span>
                                    map_radius, -q + map_radius<span class="paren">)</span>
                                    ;
    <span class="keyword">for</span>
                                    <span class="paren">(</span>
                                    <span class="type">int</span>
                                    <span class="variable-name">r</span>
                                    = r1; r &lt;= r2; r++<span class="paren">)</span>
                                    <span class="minor-control-construct">
                                        <span class="paren">{</span>
                                    </span>
                                    map.insert<span class="paren">(</span>
                                    Hex<span class="paren">(</span>
                                    q, r, -q-r<span class="paren">))</span>
                                    ;
    
                                    <span class="minor-control-construct">
                                        <span class="paren">}</span>
                                    </span>
                                    <span class="minor-control-construct">
                                        <span class="paren">}</span>
                                    </span>
                                </pre>
                            </div>
                            <p>Here &#8217;s what I get for pointy top and flat top orientations:</p>
                            <canvas id="shape-pointy-hexagon" width="300" height="200"></canvas>
                            <canvas id="shape-flat-hexagon" width="300" height="200"></canvas>
                        </div>
                    </div>
                    <div id="outline-container-org20cbba4" class="outline-4">
                        <h4 id="org20cbba4">
                            <span class="section-number-4">4.2.4</span>
                            Rectangles
                        </h4>
                        <div class="outline-text-4" id="text-4-2-4">
                            <p>
                                With axial/cube coordinates, getting rectangular maps is a little trickier! The <a href="./#map-storage">main article</a>
                                gives a clue but I don &#8217;t actually show the code. Here &#8217;s the code:
                            </p>
                            <div class="org-src-container">
                                <pre class="src src-cpp">
                                    <span class="type">unordered_set</span>
                                    &lt;Hex &gt;<span class="variable-name">map</span>
                                    ;
<span class="keyword">for</span>
                                    <span class="paren">(</span>
                                    <span class="type">int</span>
                                    <span class="variable-name">r</span>
                                    = <span class="constant">0</span>
                                    ; r &lt;map_height; r++<span class="paren">)</span>
                                    <span class="minor-control-construct">
                                        <span class="paren">{</span>
                                    </span>
                                    <span class="type">int</span>
                                    <span class="variable-name">r_offset</span>
                                    = floor<span class="paren">(</span>
                                    r/<span class="constant">2</span>
                                    <span class="paren">)</span>
                                    ; <span class="comment-delimiter">// </span>
                                    <span class="comment">or r &gt;&gt;1</span>
                                    <span class="keyword">for</span>
                                    <span class="paren">(</span>
                                    <span class="type">int</span>
                                    <span class="variable-name">q</span>
                                    = -r_offset; q &lt;map_width - r_offset; q++<span class="paren">)</span>
                                    <span class="minor-control-construct">
                                        <span class="paren">{</span>
                                    </span>
                                    map.insert<span class="paren">(</span>
                                    Hex<span class="paren">(</span>
                                    q, r, -q-r<span class="paren">))</span>
                                    ;
    
                                    <span class="minor-control-construct">
                                        <span class="paren">}</span>
                                    </span>
                                    <span class="minor-control-construct">
                                        <span class="paren">}</span>
                                    </span>
                                </pre>
                            </div>
                            <p>
                                As before, I have to pick two of <code>q</code>
                                , <code>r</code>
                                , <code>s</code>
                                for the loop, but this time the order matters because the outer and inner loops are different. Here &#8217;s what I get for <b>pointy top hexes</b>
                                if I set the (outer,inner) loops to (r,q), (q,s), (s,r), (q,r), (s,q), (r,s):
                            </p>
                            <canvas id="shape-pointy-rectangle-qr" width="200" height="200"></canvas>
                            <canvas id="shape-pointy-rectangle-rs" width="200" height="200"></canvas>
                            <canvas id="shape-pointy-rectangle-sq" width="200" height="200"></canvas>
                            <canvas id="shape-pointy-rectangle-rq" width="200" height="200"></canvas>
                            <canvas id="shape-pointy-rectangle-sr" width="200" height="200"></canvas>
                            <canvas id="shape-pointy-rectangle-qs" width="200" height="200"></canvas>
                            <p>
                                They &#8217;re rectangles, but they &#8217;re don &#8217;t have to be oriented with the x-y axes! Most likely you want the first one, with <code>r</code>
                                for the outer loop and <code>q</code>
                                for the inner loop.
                            </p>
                            <p>
                                How about <b>flat topped hexes</b>
                                ? Let &#8217;s set the (outer,inner) loops to (r,q), (q,s), (s,r), (q,r), (s,q), (r,s):
                            </p>
                            <canvas id="shape-flat-rectangle-qr" width="200" height="200"></canvas>
                            <canvas id="shape-flat-rectangle-rs" width="200" height="200"></canvas>
                            <canvas id="shape-flat-rectangle-sq" width="200" height="200"></canvas>
                            <canvas id="shape-flat-rectangle-rq" width="200" height="200"></canvas>
                            <canvas id="shape-flat-rectangle-sr" width="200" height="200"></canvas>
                            <canvas id="shape-flat-rectangle-qs" width="200" height="200"></canvas>
                            <p>
                                To get the fourth one, you can make <code>q</code>
                                the outer loop and <code>r</code>
                                the inner loop, and switch <code>width</code>
                                and <code>height</code>
                                :
                            </p>
                            <div class="org-src-container">
                                <pre class="src src-cpp">
                                    <span class="type">unordered_set</span>
                                    &lt;Hex &gt;<span class="variable-name">map</span>
                                    ;
<span class="keyword">for</span>
                                    <span class="paren">(</span>
                                    <span class="type">int</span>
                                    <span class="variable-name">q</span>
                                    = <span class="constant">0</span>
                                    ; q &lt;map_width; q++<span class="paren">)</span>
                                    <span class="minor-control-construct">
                                        <span class="paren">{</span>
                                    </span>
                                    <span class="type">int</span>
                                    <span class="variable-name">q_offset</span>
                                    = floor<span class="paren">(</span>
                                    q/<span class="constant">2</span>
                                    <span class="paren">)</span>
                                    ; <span class="comment-delimiter">// </span>
                                    <span class="comment">or q &gt;&gt;1</span>
                                    <span class="keyword">for</span>
                                    <span class="paren">(</span>
                                    <span class="type">int</span>
                                    <span class="variable-name">r</span>
                                    = -q_offset; r &lt;map_height - q_offset; r++<span class="paren">)</span>
                                    <span class="minor-control-construct">
                                        <span class="paren">{</span>
                                    </span>
                                    map.insert<span class="paren">(</span>
                                    Hex<span class="paren">(</span>
                                    q, r, -q-r<span class="paren">))</span>
                                    ;
    
                                    <span class="minor-control-construct">
                                        <span class="paren">}</span>
                                    </span>
                                    <span class="minor-control-construct">
                                        <span class="paren">}</span>
                                    </span>
                                </pre>
                            </div>
                            <p>
                                There are two versions of the loop that will produce essentially the same shape, but with minor differences. You might also need to experiment to get exactly the map you want. Try setting the offset to <code>floor((q+1)/2)</code>
                                or <code>floor((q-1)/2)</code>
                                instead of <code>floor(q/2)</code>
                                for example, and the boundary will change slightly.
                            </p>
                        </div>
                    </div>
                </div>
                <div id="outline-container-orga2b2983" class="outline-3">
                    <h3 id="map-optimized-storage">
                        <a id="orga2b2983"></a>
                        <span class="section-number-3">4.3</span>
                        Optimized storage<a class="anchor" href="#map-optimized-storage">#</a>
                    </h3>
                    <div class="outline-text-3" id="text-map-optimized-storage">
                        <p>
                            The hash table approach is pretty generic and works with any shape of map, including weird shapes and shapes with holes. You can view it as a type of node-and-edge graph structure, storing the nodes but explicitly but calculating the edges on the fly with the <code>hex_neighbor</code>
                            function.
                        </p>
                        <p>A different way to store the node-and-edge graph structure is to calculate all the edges ahead of time and store them explicitly. Give each node an integer id and then use an array of arrays to store neighbors. Or make each node an object and use a field to store a list of neighbors. These graph structures are also generic and work with any shape of map. You can also use any graph algorithm on them, such as movement range, distance map, or pathfinding. Storing the edges implicitly works well when the map is regular or is being edited; storing them explicitly can work well when the map is irregularly shaped (boundary, walls, holes) and isn &#8217;t changing frequently.</p>
                        <p>
                            Some map shapes also allow a compact 2d or 1d array. The <a href="./#map-storage">main article</a>
                            gives a visual explanation. Here, I &#8217;ll give an explanation based on code. The main idea is that for all the map shapes, there is a nested loop of the form
                        </p>
                        <div class="org-src-container">
                            <pre class="src src-cpp">
                                <span class="keyword">for</span>
                                <span class="paren">(</span>
                                <span class="type">int</span>
                                <span class="variable-name">a</span>
                                = a1; a &lt;a2; a++<span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="keyword">for</span>
                                <span class="paren">(</span>
                                <span class="type">int</span>
                                <span class="variable-name">b</span>
                                = b1; b &lt;b2; b++<span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                ...
    
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                            </pre>
                        </div>
                        <p>
                            For compact map storage, I &#8217;ll make an array of arrays, and index it with <code>array[a-a1][b-b1]</code>
                            . I <i>subtract where the loop starts</i>
                            so that the first index will be 0. For example, here &#8217;s the code for a rectangular shape <b>with pointy top hexes</b>
                            : (for flat top hexes, the loop is different)
                        </p>
                        <div class="org-src-container">
                            <pre class="src src-cpp">
                                <span class="keyword">for</span>
                                <span class="paren">(</span>
                                <span class="type">int</span>
                                <span class="variable-name">r</span>
                                = <span class="constant">0</span>
                                ; r &lt;height; r++<span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="type">int</span>
                                <span class="variable-name">r_offset</span>
                                = floor<span class="paren">(</span>
                                r/<span class="constant">2</span>
                                <span class="paren">)</span>
                                ;
    <span class="keyword">for</span>
                                <span class="paren">(</span>
                                <span class="type">int</span>
                                <span class="variable-name">q</span>
                                = -r_offset; q &lt;width - r_offset; q++<span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                map.insert<span class="paren">(</span>
                                Hex<span class="paren">(</span>
                                q, r, -q-r<span class="paren">))</span>
                                ;
    
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                            </pre>
                        </div>
                        <p>
                            For pointy top hexes, variable <code>a</code>
                            is <code>r</code>
                            , and <code>b</code>
                            is <code>q</code>
                            . (For flat top hexes, <code>a</code>
                            will be <code>q</code>
                            and <code>b</code>
                            will be <code>r</code>
                            , but I haven &#8217;t worked through that example.) Value <code>a1</code>
                            (where the <code>r</code>
                            loop starts) is <code>0</code>
                            and <code>b1</code>
                            (where the <code>q</code>
                            loop starts) is <code>-floor(r/2)</code>
                            . That means the array will be indexed <code>array[r-0][q-(-floor(r/2))]</code>
                            which simplifies to <code>array[r][q+floor(r/2)]</code>
                            . Note that <code>floor(r/2)</code>
                            can be written <code>r &gt;&gt;1</code>
                            .
                        </p>
                        <p>
                            The second thing I need to know is the <i>size</i>
                            of the arrays. I need <code>a2-a1</code>
                            arrays, and the size of each should be <code>b2-b1</code>
                            . (Be sure to check for off-by-1 errors: if the loop is written <kbd>a &lt;= a2</kbd>
                            then you &#8217;ll want <code>a2-a1+1</code>
                            arrays, and similarly for <kbd>b &lt;= b2</kbd>
                            .) I can build these arrays using C++ vectors using this pattern:
                        </p>
                        <div class="org-src-container">
                            <pre class="src src-cpp">
                                <span class="type">vector</span>
                                &lt;<span class="type">vector</span>
                                &lt;T &gt;&gt;<span class="function-name">map</span>
                                <span class="paren">(</span>
                                a2-a1<span class="paren">)</span>
                                ;
<span class="keyword">for</span>
                                <span class="paren">(</span>
                                <span class="type">int</span>
                                <span class="variable-name">a</span>
                                = a1; a &lt;a2; a++<span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                map.emplace_back<span class="paren">(</span>
                                b2-b1<span class="paren">)</span>
                                ;

                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                            </pre>
                        </div>
                        <p>
                            For the rectangle example, <code>a2-a1</code>
                            becomes <code>height</code>
                            and <code>b2-b1</code>
                            becomes <code>width</code>
                            :
                        </p>
                        <div class="org-src-container">
                            <pre class="src src-cpp">
                                <span class="type">vector</span>
                                &lt;<span class="type">vector</span>
                                &lt;T &gt;&gt;<span class="function-name">map</span>
                                <span class="paren">(</span>
                                height<span class="paren">)</span>
                                ;
<span class="keyword">for</span>
                                <span class="paren">(</span>
                                <span class="type">int</span>
                                <span class="variable-name">r</span>
                                = <span class="constant">0</span>
                                ; r &lt;height; r++<span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                map.emplace_back<span class="paren">(</span>
                                width<span class="paren">)</span>
                                ;

                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                            </pre>
                        </div>
                        <p>I can encapsulate all of this into a Map class:</p>
                        <div class="org-src-container">
                            <pre class="src src-cpp">
                                <span class="keyword">template</span>
                                &lt;<span class="keyword">class</span>
                                <span class="type">T</span>
                                &gt;<span class="keyword">class</span>
                                <span class="type">RectangularPointyTopMap</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="type">vector</span>
                                &lt;<span class="type">vector</span>
                                &lt;<span class="type">T</span>
                                &gt;&gt;<span class="variable-name">map</span>
                                ;

  <span class="keyword">public</span>
                                :
    <span class="function-name">Map</span>
                                <span class="paren">(</span>
                                <span class="type">int</span>
                                <span class="variable-name">width</span>
                                , <span class="type">int</span>
                                <span class="variable-name">height</span>
                                <span class="paren">)</span>
                                : <span class="function-name">map</span>
                                <span class="paren">(</span>
                                height<span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="keyword">for</span>
                                <span class="paren">(</span>
                                <span class="type">int</span>
                                <span class="variable-name">r</span>
                                = <span class="constant">0</span>
                                ; r &lt;height; r++<span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                map.emplace_back<span class="paren">(</span>
                                width<span class="paren">)</span>
                                ;
        
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                <span class="keyword">inline</span>
                                <span class="type">T</span>
                                &amp;<span class="function-name">at</span>
                                <span class="paren">(</span>
                                <span class="type">int</span>
                                <span class="variable-name">q</span>
                                , <span class="type">int</span>
                                <span class="variable-name">r</span>
                                <span class="paren">)</span>
                                <span class="minor-control-construct">
                                    <span class="paren">{</span>
                                </span>
                                <span class="major-control-construct">return</span>
                                map<span class="paren">[</span>
                                r<span class="paren">][</span>
                                q + <span class="paren">(</span>
                                r &gt;&gt;<span class="constant">1</span>
                                <span class="paren">)]</span>
                                ;
    
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                <span class="minor-control-construct">
                                    <span class="paren">}</span>
                                </span>
                                ;

                            </pre>
                        </div>
                        <p>
                            For the other map shapes, it &#8217;s only slightly more complicated, but the same pattern applies: I have to <i>study the loop that created the map</i>
                            in order to figure out the <i>size</i>
                            and <i>array access</i>
                            for the map.
                        </p>
                        <p>
                            1d arrays are trickier and I won &#8217;t try to tackle them here. In practice, <b>I rarely use array storage</b>
                            for hex maps, except when the maps are large, and my code is written in C++. Although it &#8217;s more compact, it almost never makes a difference in practice in my projects. For most of my projects, I use a graph representation. It gives me the most flexibility and reusability. I only need the more compact storage when storage size matters.
                        </p>
                    </div>
                </div>
            </section>
            <section>
                <h2 id="rotation">
                    <a class="anchor" href="#rotation">#</a>
                    <span class="section-number">5  </span>
                    Rotation
                </h2>
                <div class="outline-text-2" id="text-rotation">
                    <p>There are two one-step rotation functions, but which is “left” and which is “right” depends on your map orientation. You may have to swap these.</p>
                    <div class="org-src-container">
                        <pre class="src src-cpp">
                            <span class="type">Hex</span>
                            <span class="function-name">hex_rotate_left</span>
                            <span class="paren">(</span>
                            <span class="type">Hex</span>
                            <span class="variable-name">a</span>
                            <span class="paren">)</span>
                            <span class="minor-control-construct">
                                <span class="paren">{</span>
                            </span>
                            <span class="major-control-construct">return</span>
                            Hex<span class="paren">(</span>
                            -a.s, -a.q, -a.r<span class="paren">)</span>
                            ;

                            <span class="minor-control-construct">
                                <span class="paren">}</span>
                            </span>
                            <span class="type">Hex</span>
                            <span class="function-name">hex_rotate_right</span>
                            <span class="paren">(</span>
                            <span class="type">Hex</span>
                            <span class="variable-name">a</span>
                            <span class="paren">)</span>
                            <span class="minor-control-construct">
                                <span class="paren">{</span>
                            </span>
                            <span class="major-control-construct">return</span>
                            Hex<span class="paren">(</span>
                            -a.r, -a.s, -a.q<span class="paren">)</span>
                            ;

                            <span class="minor-control-construct">
                                <span class="paren">}</span>
                            </span>
                        </pre>
                    </div>
                    <p>
                        Note that these are slightly different from the <a href="./#rotation">main page</a>
                        because q,r,s don &#8217;t quite line up with x,y,z.
                    </p>
                    <p>
                        If you think of the coordinates <i>v</i>
                        in vector format, these operations are 3x3 matrix multiplies, M times <i>v</i>
                        , where M = [0 0 -1; -1 0 0; 0 -1 0]. The matrix inverse M<sup>-1</sup>
                        = [0 -1 0; 0 0 -1; -1 0 0] rotates in the opposite direction. Raising the matrix to a power M
                        <sup>
                            <i>k</i>
                        </sup>
                        rotates <i>k</i>
                        times. You can precomputate all the rotation matrices, or combine the matrix with other operations such as translate, scale, etc.
                    </p>
                </div>
            </section>
            <section>
                <h2 id="offset">
                    <a class="anchor" href="#offset">#</a>
                    <span class="section-number">6  </span>
                    Offset coordinates
                </h2>
                <div class="outline-text-2" id="text-offset">
                    <p>
                        In the main article I use the names <code>q</code>
                        and <code>r</code>
                        for offset coordinates, but since I &#8217;m using those for cube/axial, I &#8217;m going to use <code>col</code>
                        and <code>row</code>
                        here.
                    </p>
                    <div class="org-src-container">
                        <pre class="src src-cpp">
                            <span class="keyword">struct</span>
                            <span class="type">OffsetCoord</span>
                            <span class="minor-control-construct">
                                <span class="paren">{</span>
                            </span>
                            <span class="keyword">const</span>
                            <span class="type">int</span>
                            <span class="variable-name">col</span>
                            , <span class="variable-name">row</span>
                            ;
    <span class="function-name">OffsetCoord</span>
                            <span class="paren">(</span>
                            <span class="type">int</span>
                            <span class="variable-name">col_</span>
                            , <span class="type">int</span>
                            <span class="variable-name">row_</span>
                            <span class="paren">)</span>
                            : col<span class="paren">(</span>
                            col_<span class="paren">)</span>
                            , row<span class="paren">(</span>
                            row_<span class="paren">)</span>
                            <span class="minor-control-construct">
                                <span class="paren">{}</span>
                            </span>
                            <span class="minor-control-construct">
                                <span class="paren">}</span>
                            </span>
                            ;

                        </pre>
                    </div>
                    <p>
                        I &#8217;m expecting that I &#8217;ll use the cube/axial <b>Hex</b>
                        class everywhere, except for displaying to the player. That &#8217;s where offset coordinates will be useful. That means the only operations I need are converting <b>Hex</b>
                        to <b>OffsetCoord</b>
                        and back.
                    </p>
                    <p>
                        There are four offset types: odd-r, even-r, odd-q, even-q. The &#8220;r &#8221;types are used with with pointy top hexagons and the &#8220;q &#8221;types are used with flat top. Whether it &#8217;s even or odd can be encoded as an offset direction <b>+1</b>
                        or <b>-1</b>
                        . For pointy top, the offset direction tells us whether to slide alternate rows right or left. For flat top, the offset direction tells us whether to slide alternate columns up or down.
                    </p>
                    <div class="org-src-container">
                        <pre class="src src-cpp">
                            <span class="keyword">const</span>
                            <span class="type">int</span>
                            <span class="variable-name">EVEN</span>
                            = <span class="constant">1</span>
                            ;
<span class="keyword">const</span>
                            <span class="type">int</span>
                            <span class="variable-name">ODD</span>
                            = -<span class="constant">1</span>
                            ;

<span class="type">OffsetCoord</span>
                            <span class="function-name">qoffset_from_cube</span>
                            <span class="paren">(</span>
                            <span class="type">int</span>
                            <span class="variable-name">offset</span>
                            , <span class="type">Hex</span>
                            <span class="variable-name">h</span>
                            <span class="paren">)</span>
                            <span class="minor-control-construct">
                                <span class="paren">{</span>
                            </span>
                            <span class="type">int</span>
                            <span class="variable-name">col</span>
                            = h.q;
    <span class="type">int</span>
                            <span class="variable-name">row</span>
                            = h.r + <span class="type">int</span>
                            <span class="paren">((</span>
                            h.q + offset * <span class="paren">(</span>
                            h.q &amp;<span class="constant">1</span>
                            <span class="paren">))</span>
                            / <span class="constant">2</span>
                            <span class="paren">)</span>
                            ;
    <span class="major-control-construct">return</span>
                            OffsetCoord<span class="paren">(</span>
                            col, row<span class="paren">)</span>
                            ;

                            <span class="minor-control-construct">
                                <span class="paren">}</span>
                            </span>
                            <span class="type">Hex</span>
                            <span class="function-name">qoffset_to_cube</span>
                            <span class="paren">(</span>
                            <span class="type">int</span>
                            <span class="variable-name">offset</span>
                            , <span class="type">OffsetCoord</span>
                            <span class="variable-name">h</span>
                            <span class="paren">)</span>
                            <span class="minor-control-construct">
                                <span class="paren">{</span>
                            </span>
                            <span class="type">int</span>
                            <span class="variable-name">q</span>
                            = h.col;
    <span class="type">int</span>
                            <span class="variable-name">r</span>
                            = h.row - <span class="type">int</span>
                            <span class="paren">((</span>
                            h.col + offset * <span class="paren">(</span>
                            h.col &amp;<span class="constant">1</span>
                            <span class="paren">))</span>
                            / <span class="constant">2</span>
                            <span class="paren">)</span>
                            ;
    <span class="type">int</span>
                            <span class="variable-name">s</span>
                            = -q - r;
    <span class="major-control-construct">return</span>
                            Hex<span class="paren">(</span>
                            q, r, s<span class="paren">)</span>
                            ;

                            <span class="minor-control-construct">
                                <span class="paren">}</span>
                            </span>
                            <span class="type">OffsetCoord</span>
                            <span class="function-name">roffset_from_cube</span>
                            <span class="paren">(</span>
                            <span class="type">int</span>
                            <span class="variable-name">offset</span>
                            , <span class="type">Hex</span>
                            <span class="variable-name">h</span>
                            <span class="paren">)</span>
                            <span class="minor-control-construct">
                                <span class="paren">{</span>
                            </span>
                            <span class="type">int</span>
                            <span class="variable-name">col</span>
                            = h.q + <span class="type">int</span>
                            <span class="paren">((</span>
                            h.r + offset * <span class="paren">(</span>
                            h.r &amp;<span class="constant">1</span>
                            <span class="paren">))</span>
                            / <span class="constant">2</span>
                            <span class="paren">)</span>
                            ;
    <span class="type">int</span>
                            <span class="variable-name">row</span>
                            = h.r;
    <span class="major-control-construct">return</span>
                            OffsetCoord<span class="paren">(</span>
                            col, row<span class="paren">)</span>
                            ;

                            <span class="minor-control-construct">
                                <span class="paren">}</span>
                            </span>
                            <span class="type">Hex</span>
                            <span class="function-name">roffset_to_cube</span>
                            <span class="paren">(</span>
                            <span class="type">int</span>
                            <span class="variable-name">offset</span>
                            , <span class="type">OffsetCoord</span>
                            <span class="variable-name">h</span>
                            <span class="paren">)</span>
                            <span class="minor-control-construct">
                                <span class="paren">{</span>
                            </span>
                            <span class="type">int</span>
                            <span class="variable-name">q</span>
                            = h.col - <span class="type">int</span>
                            <span class="paren">((</span>
                            h.row + offset * <span class="paren">(</span>
                            h.row &amp;<span class="constant">1</span>
                            <span class="paren">))</span>
                            / <span class="constant">2</span>
                            <span class="paren">)</span>
                            ;
    <span class="type">int</span>
                            <span class="variable-name">r</span>
                            = h.row;
    <span class="type">int</span>
                            <span class="variable-name">s</span>
                            = -q - r;
    <span class="major-control-construct">return</span>
                            Hex<span class="paren">(</span>
                            q, r, s<span class="paren">)</span>
                            ;

                            <span class="minor-control-construct">
                                <span class="paren">}</span>
                            </span>
                        </pre>
                    </div>
                    <p>
                        If you &#8217;re only using even or odd, you can hard-code the value of <code>offset</code>
                        into the code, making it simpler and faster. Alternatively, <code>offset</code>
                        can be a template parameter so that the compiler can inline and optimize it.
                    </p>
                    <p>
                        For offset coordinates I need to know if a row/col is even or odd, and use <code>a &amp;1</code>
                        (<a href="http://en.wikipedia.org/wiki/Bitwise_operation#AND">bitwise and</a>
                        ) instead of <code>a%2</code>
                        return 0 or +1. Why?
                    </p>
                    <ul class="org-ul">
                        <li>
                            On systems using <a href="http://en.wikipedia.org/wiki/Two's_complement">two &#8217;s complement</a>
                            representation, which is just about every system out there, <code>a &amp;1</code>
                            returns 0 for even <code>a</code>
                            and 1 for odd <code>a</code>
                            . This is what I want. However, it &#8217;s not strictly portable.
                        </li>
                        <li>
                            In some languages, including C++, <code>a%2</code>
                            computes <a href="http://en.wikipedia.org/wiki/Modular_arithmetic#Remainders">remainder</a>
                            , not modulo. When <code>a</code>
                            is -1, I want to say that &#8217;s odd, so I want <code>a%2</code>
                            to be 1, but some systems will return -1. If your language computes modulo, you can safely use <code>a%2</code>
                            .
                        </li>
                        <li>
                            If you know that your coordinate <code>a</code>
                            will never be negative, you can safely use <code>a%2</code>
                            .
                        </li>
                        <li>
                            If you don &#8217;t have <code>a &amp;1</code>
                            available, you can use <code>abs(a) % 2</code>
                            instead.
                        </li>
                    </ul>
                    <p>
                        Also, in many (all?) languages, <code>&amp;</code>
                        has lower precedence than <code>+</code>
                        so be sure to parenthesize <code>a &amp;1</code>
                        .
                    </p>
                </div>
            </section>
            <section>
                <h2 id="notes">
                    <a class="anchor" href="#notes">#</a>
                    <span class="section-number">7  </span>
                    Notes
                </h2>
                <div class="outline-text-2" id="text-notes">
                    <ul class="org-ul">
                        <li>
                            In languages that don &#8217;t support <code>a &gt;&gt;1</code>
                            , you can use <code>floor(a/2)</code>
                            instead.
                        </li>
                        <li>Most of the functions are small and should be inlined in languages that support it.</li>
                        <li>
                            Operator overloading is sometimes abused, but might be nice for the arithmetic Hex operations <code>hex_add</code>
                            , <code>hex_subtract</code>
                            , <code>hex_scale</code>
                            . I didn &#8217;t use it here.
                        </li>
                        <li>I wrote this code in module style, but you might prefer to write it as class style, where the functions are static or class methods. In some languages, class style is the only choice. Some of the methods might be better as instance methods.</li>
                        <li>In languages that support more than one constructor, or optional arguments, it might be handy to have both the two-argument axial constructor and the three-argument cube constructor.</li>
                    </ul>
                </div>
                <div id="outline-container-orgaf61d26" class="outline-3">
                    <h3 id="cube-vs-axial">
                        <a id="orgaf61d26"></a>
                        <span class="section-number-3">7.1</span>
                        Cube vs Axial<a class="anchor" href="#cube-vs-axial">#</a>
                    </h3>
                    <div class="outline-text-3" id="text-cube-vs-axial">
                        <p>Cube coordinates are three numbers, but one can be computed from the others. Whether you want to store the third one as a field or compute it in an accessor is primarily a code style decision. If performance is the main concern, the cost of the accessor vs the cost of the computation will matter most. In languages like C++ where accessors are inlined away, save the memory (accessing RAM is expensive) and use an accessor. In languages like Python where accessors are expensive, save the function call (function calls are expensive) and store the third coordinate in a field.</p>
                        <p>
                            Also take a look at <a href="http://cs.ucla.edu/~tianyi.zhang/perfdiff.pdf">this paper</a>
                            which found axial and cube to be faster than offset for line of sight, distance, and other algorithms, but slower than offset for displaying offset coordinates (as expected). I can &#8217;t find their code though.
                        </p>
                        <p>
                            If performance matters, the best thing to do is to <i>actually measure it</i>
                            .
                        </p>
                    </div>
                </div>
                <div id="outline-container-orgf8f1cd4" class="outline-3">
                    <h3 id="cpp">
                        <a id="orgf8f1cd4"></a>
                        <span class="section-number-3">7.2</span>
                        C++<a class="anchor" href="#cpp">#</a>
                    </h3>
                    <div class="outline-text-3" id="text-cpp">
                        <ul class="org-ul">
                            <li>
                                These are all value types, cheap to copy and pass around. For a bit more compactness, if your maps are small you can use an int16 or int8 for the Hex and Offset class. If you &#8217;re computing <code>s</code>
                                in an accessor, storing <code>q</code>
                                and <code>r</code>
                                (or <code>col</code>
                                and <code>row</code>
                                ) as int16 will let you fit the entire coordinate into 32 bits.
                            </li>
                            <li>As written, these classes have a non-default constructor, so they won &#8217;t count as a POD trivial type, although I think they count as a POD standard-layout type. Switch to a default constructor and use struct initialization if you &#8217;d like them to be a POD trivial type.</li>
                            <li>
                                I could have written a template class <code>Hex &lt;&gt;</code>
                                and instantiated it as <code>Hex &lt;int &gt;</code>
                                and <code>Hex &lt;double &gt;</code>
                                . I decided not to because I expect that many of the readers will be translating the code to another language.
                            </li>
                        </ul>
                    </div>
                </div>
                <div id="outline-container-org969f891" class="outline-3">
                    <h3 id="dynamic-typing">
                        <a id="org969f891"></a>
                        <span class="section-number-3">7.3</span>
                        Python, Javascript<a class="anchor" href="#dynamic-typing">#</a>
                    </h3>
                    <div class="outline-text-3" id="text-dynamic-typing">
                        <ul class="org-ul">
                            <li>Python and other dynamically typed languages don &#8217;t need Hex and FractionalHex to be separate. You can write the FractionalHex functions to work with Hex instead, and skip the FractionalHex class.</li>
                        </ul>
                    </div>
                </div>
            </section>
            
        </main>
        <footer>
                <div>
                    <script src="js/hex.js"></script>
                    <script src="js/hex-implementation.js"></script>
                </div>
        </footer>
    </body>
</html>
